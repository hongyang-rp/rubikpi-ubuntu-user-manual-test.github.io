---
# Display h2 to h5 headings
toc_min_heading_level: 2
toc_max_heading_level: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 外设与接口

帮助您快速了解魔方派 3 的外设与接口。

通过本章节，您可以了解魔方派各类硬件接口的使用方法，与一般问题的排查方法。

本章节中，只说明外设与接口的命令行的使用方法; 对于大部分功能，您可以直接在桌面系统中通过操作带有图形界面的 APP 来运行。

## 硬件资源图

![](images/image-101.png)

| 序号 | 接口                           | 序号 | 接口                         |
|------|--------------------------------|------|------------------------------|
| 1    | RTC 电池接口                   | 10   | Type-C 电源接口              |
| 2    | Micro USB (UART 调试)          | 11   | PWR 按键                     |
| 3    | TurboX C6490P SOM              | 12   | EDL 按键                     |
| 4    | 3.5mm 耳机接口                 | 13   | 摄像头接口 2                 |
| 5    | USB Type-C with DP (USB 3.1)   | 14   | 摄像头接口 1                 |
| 6    | USB Type-A (USB 2.0)           | 15   | Wi-Fi/蓝牙模块               |
| 7    | 2 x USB Type-A (USB 3.0)       | 16   | 风扇接口                     |
| 8    | 1000M 以太网                   | 17   | 40-pin 连接器                |
| 9    | HDMI OUT                       | 18   | M.2 Key M 接口               |

## 40 pin 连接器

### GPIO

RUBIK Pi 3 适配了 WiringRP（基于高性能 GPIO 编程库 WiringPi），推荐使用 WiringRP 来控制 GPIO，和对 GPIO 编程。关于 WiringRP 详细信息可访问 https://github.com/rubikpi-ai/WiringRP 查看。

#### 引脚分布

下图是 RUBIK Pi 3 40-pin 连接器的引脚默认功能，其中大部分引脚和树梅派 40-pin 连接器引脚的默认功能兼容。

![](images/image-96.png)

下表是 40-pin连接器支持的所有功能，图中蓝色字体表明默认功能。

![](images/image-94.png)

#### 使用 GPIO

在魔方派 3 中可以使用 shell 命令，或使用编程语言来控制 GPIO。

<Tabs>
    <TabItem value="GPIO Shell" label="Shell 命令" default>
    在 RUBIK Pi 3 中执行下面的步骤控制 GPIO。
    :::note
    下面命令需要使用 root 权限：

     * 使用 `sudo -i` 命令切换到 root 用户。

        或

     * 在普通用户下，在命令前加入 `sudo` ，如 `sudo gpio readall`，根据提示输入用户的登录密码。
    :::

    * 使用 WiringRP 相关命令

        使用前需按下面方法安装 WiringRP：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP.
        ```shell
        sudo apt install wiringrp
        ```

        安装完成后可以使用下面命令操作 GPIO：

        * 查看 GPIO 状态

        ```shell
        gpio readall
        ```

        ![](images/image-98.png)
        * 设置 GPIO 模式

        ```shell
        gpio mode 15 in             # 将15号引脚模式置为输入
        gpio pins                   # 查看更改之后的状态
        gpio mode 15 out            # 将15号引脚模式置为输出
        gpio pins                   # 查看更改之后的状态
        ```

        * 设置引脚电平

        ```shell
        gpio write 15 1             # 将15号引脚置为高电平
        gpio read 15                # 读取更改后引脚状态
        gpio write 15 0             # 将15号引脚置为低电平
        gpio read 15                # 读取更改后引脚状态
        ```

    * 操作 */sys/class/gpio* 下相关节点
        GPIO 子系统的编号如下表。

        ![](images/20250603-170502.jpg)

        1. 进入 */sys/class/gpio* 目录：

        ```
        cd /sys/class/gpio
        ```

        2. 将要控制的 GPIO 导出，如控制 13 号引脚 GPIO_24：
        ```
        echo 571 > export
        ```

        3. 进入到 gpio571 目录设置 GPIO 属性：

        ```
        cd gpio571
        ls
        ```
        ![](images/20250603-174456.jpg)

        - direction（方向）：

            - 输入：in
            - 输出：out
            - value（值）：
            - 低电平：0
            - 高电平：1
        - edge （中断边沿）：
            - 上升沿触发：rising
            - 下降沿触发：falling
            - 双边沿触发：both
            - 禁用中断：none

        4. 如设置 13 号引脚输出高电平：

        ```
        echo out > direction
        echo 1 > value
        ```
        5. 取消导出 13 号引脚到用户空间：

        ```
        echo 571 > unexport
        ```

    </TabItem>
    <TabItem value="GPIO WiringRP-c" label="WiringRP" default>
        WiringRP 库中提供了一系列的 API 函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP.
        ```shell
        sudo apt install wiringrp
        ```

        以下代码示例，代码将 13 号引脚设置为输出， 15 号引脚设置为输入，循环检测 15 号引脚的电平状态：

        ```c
        #include <stdio.h>
        #include <wiringPi.h>

        int main (void)
        {
          wiringPiSetup () ;
          pinMode (13, OUTPUT) ;
          pinMode (15, INPUT) ;

          for (;;)
          {
            digitalWrite (13, HIGH) ;        // On
            printf("%d\n", digitalRead (15));        // On
            delay (1000) ;                // mS
            digitalWrite (13, LOW) ;        // Off
            printf("%d\n", digitalRead (15));        // On
            delay (1900) ;
          }

          return 0 ;
        }

        ```
        在 RUBIK Pi 3 中编译程序

          ```shell
          gcc gpio.c -o gpio -lwiringPi
          ```

          :::note
          若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
          :::
        将 13 和 15 号引脚使用杜邦线短接，测试 GPIO 电平控制和电平读取情况，如下图所示：
        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155538.jpg)

        运行如下命令：

        ```shell
        ./gpio
        ```

        程序运行结果如下：

        ![](images/image-113.png)


    </TabItem>
    <TabItem value="GPIO WiringRP-python" label="WiringRP-Python" default>
        WiringRP-Python 库中提供了一系列的 API 函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP-Python：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP-Python.
        ```shell
        sudo apt install wiringrp-python
        ```

        下方截取代码是使用 WiringRP 库操作 GPIO 的示例，其中将 13 号引脚设置为输出，15 号引脚设置为输入，循环检测 15 号引脚的电平状态。

        ```python
        import wiringpi
        import time

        wiringpi.wiringPiSetup()
        wiringpi.pinMode(13, 1)
        wiringpi.pinMode(15, 0)
        wiringpi.digitalRead(15)

        while True:
            wiringpi.digitalWrite(13,1)
            pin_level = wiringpi.digitalRead(15)
            print(f"in_gpio level: {pin_level}")

            time.sleep(1)

            wiringpi.digitalWrite(13,0)
            pin_level = wiringpi.digitalRead(15)
            print(f"in_gpio level: {pin_level}")

            time.sleep(1)
        ```

        将 13 和 15 号引脚使用杜邦线短接，测试 GPIO 电平控制和电平读取情况，如下图所示

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155538-1.jpg)

        在魔方派 3 中运行如下命令

        ```shell
        python3 gpio.py
        ```

        程序运行结果如下：

        ![](images/image-114.png)


    </TabItem>
    <TabItem value="GPIO C" label="C" default>
        以下代码示例，代码将 13 号引脚设置为输出， 15 号引脚设置为输入，循环检测 15 号引脚的电平状态：
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <unistd.h>

        int out_gpio = 571;
        int in_gpio = 572;

        int main() {
            char export_path[50] = {};
            char export_command[100] = {};
            snprintf(export_path, sizeof(export_path), "/sys/class/gpio/export");
            snprintf(export_command, sizeof(export_command), "echo %d > %s ", out_gpio, export_path);
            system(export_command);
            snprintf(export_command, sizeof(export_command), "echo %d > %s ", in_gpio, export_path);
            system(export_command);

            char direction_path[50] = {};
            snprintf(direction_path, sizeof(direction_path), "/sys/class/gpio/gpio%d/direction", out_gpio);
            FILE *direction_file = fopen(direction_path, "w");
            if (direction_file == NULL) {
                perror("Failed to open GPIO direction file");
                return -1;
            }
            fprintf(direction_file, "out");
            fclose(direction_file);

            snprintf(direction_path, sizeof(direction_path), "/sys/class/gpio/gpio%d/direction", in_gpio);
            direction_file = fopen(direction_path, "w");
            if (direction_file == NULL) {
                perror("Failed to open GPIO direction file");
                return -1;
            }
            fprintf(direction_file, "in");
            fclose(direction_file);

            char value_in_path[50] = {};
            char value_out_path[50] = {};
            char cat_command[100] = {};
            snprintf(value_out_path, sizeof(value_out_path), "/sys/class/gpio/gpio%d/value", out_gpio);
            snprintf(value_in_path, sizeof(value_in_path), "/sys/class/gpio/gpio%d/value", in_gpio);
            snprintf(cat_command, sizeof(cat_command), "cat %s", value_in_path);

            FILE *value_out_file = fopen(value_out_path, "w");
            if (value_out_file == NULL) {
                perror("Failed to open GPIO value file");
                return -1;
            }

            for (int i = 0; i < 5; i++) {
                fprintf(value_out_file, "1");
                fflush(value_out_file);

                system(cat_command);
                sleep(1);

                fprintf(value_out_file, "0");
                fflush(value_out_file);

                system(cat_command);
                sleep(1);
            }

            fclose(value_out_file);

            char unexport_path[50] = {};
            char unexport_command[100] = {};
            snprintf(unexport_path, sizeof(unexport_path), "/sys/class/gpio/unexport");
            snprintf(unexport_command, sizeof(unexport_command), "echo %d > %s ", out_gpio, unexport_path);
            system(unexport_command);
            snprintf(unexport_command, sizeof(unexport_command), "echo %d > %s ", in_gpio, unexport_path);
            system(unexport_command);

            return 0;
        }

        ```
        在魔方派 3 中编译程序：


        ```shell
        gcc gpio.c -o gpio
        ```
        :::note
        若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
        :::

        将 13 和 15 号引脚使用杜邦线短接，测试 GPIO 电平控制和电平读取情况，如下图所示：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155538-2.jpg)

        运行如下命令：

        ```shell
        ./gpio
        ```

        程序运行结果如下：

        ![](images/image-111.png)

    </TabItem>
    <TabItem value="GPIO python" label="Python" default>
        可使用 Python 的 periphery 库控制 GPIO，可在 RUBIK Pi 3 中使用下面命令进行安装：

        下方截取代码是使用 periphery 库操作 GPIO 的示例，其中将 13 号引脚设置为输出，15 号引脚设置为输入，循环检测 15 号引脚的电平状态。
        ```python
        from periphery import GPIO
        import time

        out_gpio = GPIO(571, "out")
        in_gpio = GPIO(572, "in")

        try:
            while True:
                try:
                    out_gpio.write(True)
                    pin_level = in_gpio.read()
                    print(f"in_gpio level: {pin_level}")

                    out_gpio.write(False)
                    pin_level = in_gpio.read()
                    print(f"in_gpio level: {pin_level}")

                    time.sleep(1)

                except KeyboardInterrupt:
                    out_gpio.write(False)
                    break

        except IOError:
            print("Error")

        finally:
            out_gpio.close()
            in_gpio.close()
        ```
        将 13 和 15 号引脚使用杜邦线短接测试 GPIO 电平控制和电平读取情况，如下图所示：

        :::warning
        >
        > 注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155538-3.jpg)

        运行如下命令：

        ```shell
        python3 gpio.py
         ```
        程序运行结果如下：
        ![](images/image-112.png)

    </TabItem>
</Tabs>



### I2C

I2C 是飞利浦公司在 20 世纪 80 年代开发的一种双向 2 线制总线，用于实现高效的 IC 间控制总线。总线上的每个设备都有其唯一的地址（由飞利浦公司领导的 I2C 总机构注册）。I2C 核心支持多控制器模式，以及 10 位目标地址和 10 位可扩展地址。关于 I2C 的更多信息，请参阅 https://www.i2c-bus.org/fileadmin/ftp/i2c_bus_specification_1995.pdf


RUBIK Pi 3 适配了 WiringRP（基于高性能 GPIO 编程库 WiringPi ） ，推荐使用 WiringRP 来控制 I2C，和对 I2C 编程。关于 WiringRP 详细信息可访问 https://github.com/rubikpi-ai/WiringRP 查看。

#### 引脚分布

下图是 RUBIK Pi 3 40-pin 连接器的引脚默认功能，其中大部分引脚和树梅派 40-pin 连接器引脚的默认功能兼容。

![](images/image-110.png)

:::note
3 号引脚和 5 号引脚默认已设置配为 I2C1。
:::

下表是 40-pin 连接器支持的所有功能，图中蓝色字体表明默认功能。

![](images/image-109.png)

#### 使用 I2C

在魔方派 3 中可以使用 shell 命令，或使用编程语言来控制 I2C 总线。

<Tabs>
    <TabItem value="I2C Shell" label="Shell 命令" default>
        在 RUBIK Pi 3 中执行下面步骤控制 I2C 总线。
        使用 WiringRP 相关命令前使用下面方法安装：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP.
        ```shell
        sudo apt install wiringrp

        * 使用 WiringRP 相关命令：

            ```shell
            ./gpio -x ads1115:100:10 aread 100     #通过 I2C 总线读取 ADS1115 设备的模拟信号值
            ```
        * 使用 i2cdetect 工具

            * 查看 I2C1 接口上的设备：

              ```shell
              i2cdetect -a -y -r 1
              ```

            * 读取地址为 0x38 设备的全部寄存器：

              ```shell
              i2cdump -f -y 1 0x38
              ```

            * 向地址为 0x38 设备的 0x01 寄存器地址写入 0xaa：

              ```shell
              i2cset -f -y 1 0x38 0x01 0xaa
              ```

            * 读取地址为 0x38 的设备，寄存器地址为0x01处的数值：

              ```shell
              i2cget -f -y 1 0x38 0x01
              ```

        :::note
        若无 `i2cdetect` 等命令，可执行 `apt install i2c-tools` 命令进行安装。
        :::


    </TabItem>
    <TabItem value="I2C WiringRP-c" label="WiringRP" default>
        WiringRP 库中提供了一系列的 API函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP.
        ```shell
        sudo apt install wiringrp
        ```

        以下代码示例，I2C1总线和地址为0x38的设备进行通信，向设备0x01地址处写入0xaa：

        ```c
        #include <wiringPi.h>
        #include <wiringPiI2C.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <unistd.h>

        #define I2C_ADDRESS 0x38

        int main(void)
        {
            int fd;

            if (wiringPiSetup() == -1) {
                exit(1);
            }

            fd = wiringPiI2CSetup(1, I2C_ADDRESS);
            if (fd == -1) {
                exit(1);
            }

            unsigned char data[2];
            if (read(fd, data, 2) != 2) {
                exit(1);
            }

            wiringPiI2CWriteReg8(fd, 0x01, 0xaa) ;

            close(fd);
            return 0;
        }
        ```
        RUBIK Pi 3 中编译程序：

        ```shell
        gcc i2c.c -o i2c -lwiringPi
        ```

        :::note
        若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
        :::

        将 3 和 5 号引脚连接 I2C 传感器，验证 I2C 总线通信，如下图所示

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155532-2.jpg)

        运行如下命令运行程序：

        ```shell
        ./i2c
        ```
    </TabItem>
    <TabItem value="I2C WiringRP-python" label="WiringRP-Python" default>
        WiringRP 库中提供了一系列的 API 函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP-Python：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP-Python.
        ```shell
        sudo apt install wiringrp-python
        ```

        以下代码示例，使用 I2C1 总线和地址为 0x38 的设备进行通信，向设备 0x01 地址处写入 0xaa：
        ```python
        import wiringpi as wpi

        wpi.wiringPiSetup()
        fd=wpi.wiringPiI2CSetup(0x38, 1)
        wpi.wiringPiI2CWriteReg8 (fd, 0x01, 0xaa)
        ```

        将 3 和 5 号引脚连接 I2C 传感器，验证 I2C 总线通信，如下图所示：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155532.jpg)

        ```shell
        python3 i2c.py
        ```

  运行如下命令：

    </TabItem>
    <TabItem value="I2C C" label="C" default>
        以下代码示例，I2C1 总线和地址为 0x38 的设备进行通信，向设备 0x01 地址处写入 0xaa：
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <linux/i2c-dev.h>
        #include <sys/ioctl.h>

        #define I2C_DEVICE_PATH "/dev/i2c-1"

        int main() {
            uint8_t data[2] = {0x01,0xaa};

            const char *i2c_device = I2C_DEVICE_PATH;
            int i2c_file;

            if ((i2c_file = open(i2c_device, O_RDWR)) < 0) {
                perror("Failed to open I2C device");
                return -1;
            }

            ioctl(i2c_file, I2C_TENBIT, 0);
            ioctl(i2c_file, I2C_RETRIES, 5);
            printf("i2cdetect addr : ");
            for (int x = 0; x < 0x7f; x++)
            {
                if (ioctl(i2c_file, I2C_SLAVE, x) < 0) {
                    perror("Failed to set I2C slave address");
                    close(i2c_file);
                    return -1;
                }

                if (write(i2c_file, data, 2) == 2)
                {
                    printf("0x%x,", x);
                }
            }

            close(i2c_file);
            printf("\r\n");

            return 0;
        }
        ```

        在 RUBIK Pi 3 中编译

        ```shell
        gcc i2c.c -o i2c
        ```

        :::note
        若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
        :::


        将 3 和 5 号引脚连接 I2C 传感器，验证 I2C 总线通信，如下图所示：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155532-3.jpg)

        运行如下命令：

        ```shell
        ./i2c
        ```

        程序运行结果如下：

        ![](images/image-179.png)

    </TabItem>
    <TabItem value="I2C python" label="Python" default>
        可使用 Python 的 smbus 库控制 I2C，可在 RUBIK Pi 3 中使用下面命令进行安装：

        ```shell
        apt install python3-smbus
        ```
        以下代码示例，使用 I2C1 总线和地址为 0x38 的设备进行通信，向设备 0x01 地址处写入 0xaa：

        ```python
        import smbus

        def main():
            data = [0x01, 0xaa]

            try:
                i2c_bus = smbus.SMBus(1)

                print("i2cdetect addr : ", end="")
                for address in range(0x7F):
                    try:
                        i2c_bus.write_i2c_block_data(address, 0, data)
                        print("0x{:02X},".format(address), end="")
                    except OSError:
                        pass

                print()

            except Exception as e:
                print(f"An error occurred: {e}")

            finally:
                if i2c_bus:
                    i2c_bus.close()

        if __name__ == "__main__":
            main()

        ```

        将 3 和 5 号引脚连接 I2C 传感器，验证 I2C 总线通信，如下图所示：
        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155532-1.jpg)

        运行如下命令：

        ```shell
        python3 i2c.py
        ```

        程序运行结果如下：

         ![](images/image-108.png)

    </TabItem>
</Tabs>



### SPI

串行外设接口 (SPI) 是在全双工模式下工作的同步串行数据链路。SPI 又称为 4 线制串行总线。

RUBIK Pi 3 适配了 WiringRP（基于高性能 GPIO 编程库 WiringPi），推荐使用 WiringRP 来控制 SPI，和对 SPI 编程。关于 WiringRP 详细信息可访问 https://github.com/rubikpi-ai/WiringRP 查看。

#### 引脚分布

下图是 RUBIK Pi 3 40-pin 连接器的引脚默认功能，其中大部分引脚和树梅派 40-pin 连接器引脚的默认功能兼容。

![](images/image-122.png)

:::note
 19 号、21 号、23 号、24 号引脚默认已设置配为 SPI。
:::

下表是 40-pin 连接器支持的所有功能，图中蓝色字体表明默认功能。

![](images/image-121.png)

#### 使用 SPI

<Tabs>
    <TabItem value="SPI WiringRP-c" label="WiringRP" default>
        WiringRP 库中提供了一系列的 API 函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP.
        ```shell
        sudo apt install wiringrp
        ```
        以下代码示例，代码使用 SPI 总线进行数据收发通信：
        ```c
        #include <wiringPi.h>
        #include <wiringPiSPI.h>
        #include <stdio.h>
        #include <stdlib.h>

        int main(void)
        {
            int fd;
            unsigned char send_data[64] =  "hello world!";
            unsigned char read_data[64];

            if(wiringPiSetup() == -1)
                exit(1);

            fd = wiringPiSPISetup(0, 1000000);
            if(fd < 0)
                exit(2);

                printf("\rtx_buffer: \n %s\n ", send_data);
            // Send and receive data
            if(wiringPiSPIDataRW(0, send_data, sizeof(send_data)) < 0)
                exit(3);
                printf("\rtx_buffer: \n %s\n ", send_data);


            return 0;
        }
        ```

        编译程序

        在 RUBIK Pi 3 中编译

        ```shell
        gcc spi.c -o spi -lwiringPi
        ```

        :::note
        若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
        :::

        将 19 号引脚和 21 号引脚使用杜邦线短接，验证 SPI 总线通信，如下图所示：

        :::warning

        > 注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155529-1.jpg)

        运行如下命令：

        ```shell
        ./spi
        ```

        程序执行结果如下：

        ![](images/image-123.png)

    </TabItem>
    <TabItem value="SPI WiringRP-python" label="WiringRP-Python" default>
        WiringRP-Python 库中提供了一系列的 API 函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP-Python：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP-Python.
        ```shell
        sudo apt install wiringrp-python
        ```
        以下代码示例，代码使用 SPI 总线进行数据收发通信：

        ```python
        import wiringpi as wpi

        wpi.wiringPiSetup()

        wpi.wiringPiSPISetup(0, 8000000)

        tx_buffer = bytes([72, 101, 108, 108, 111])
        print("tx_buffer:\n\r ", tx_buffer)
        retlen, rx_buffer = wpi.wiringPiSPIDataRW(0, tx_buffer)
        print("rx_buffer:\n\r ", rx_buffer)
        ```

        将 19 号引脚和 21 号引脚使用杜邦线短接，验证 SPI 总线通信，如下图所示：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155529-2.jpg)

        运行如下命令：

        ```shell
         python3 spi.py
        ```

        程序执行结果如下：

        ![](images/image-119.png)

    </TabItem>
    <TabItem value="SPI C" label="C" default>
    以下代码示例，代码使用 SPI 总线进行数据收发通信：
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <linux/spi/spidev.h>
    #include <sys/ioctl.h>

    #define SPI_DEVICE_PATH "/dev/spidev12.0"

    int main() {
        int spi_file;
        uint8_t tx_buffer[50] = "hello world!";
        uint8_t rx_buffer[50];

        // Open the SPI device
        if ((spi_file = open(SPI_DEVICE_PATH, O_RDWR)) < 0) {
            perror("Failed to open SPI device");
            return -1;
        }

        // Configure SPI mode and bits per word
        uint8_t mode = SPI_MODE_0;
        uint8_t bits = 8;

        if (ioctl(spi_file, SPI_IOC_WR_MODE, &mode) < 0) {
            perror("Failed to set SPI mode");
            close(spi_file);
            return -1;
        }
        if (ioctl(spi_file, SPI_IOC_WR_BITS_PER_WORD, &bits) < 0) {
            perror("Failed to set SPI bits per word");
            close(spi_file);
            return -1;
        }

        // Perform SPI transfer
        struct spi_ioc_transfer transfer = {
            .tx_buf = (unsigned long)tx_buffer,
            .rx_buf = (unsigned long)rx_buffer,
            .len = sizeof(tx_buffer),
            .delay_usecs = 0,
            .speed_hz = 1000000,  // SPI speed in Hz
            .bits_per_word = 8,
        };

        if (ioctl(spi_file, SPI_IOC_MESSAGE(1), &transfer) < 0) {
            perror("Failed to perform SPI transfer");
            close(spi_file);
            return -1;
        }

         /* Print tx_buffer and rx_buffer*/
        printf("\rtx_buffer: \n %s\n ", tx_buffer);
        printf("\rrx_buffer: \n %s\n ", rx_buffer);

        // Close the SPI device
        close(spi_file);

        return 0;
    }
  ```

    在魔方派 3 中编译

    ```c
    gcc spi.c -o spi
    ```

    :::note
    若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
    :::

    将 19 号引脚和 21 号引脚使用杜邦线短接，验证 SPI 总线通信，如下图所示：

    :::warning
    注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
    :::

    ![](images/20250314-155529.jpg)

    运行如下命令：

    ```shell
    ./spi
    ```

   程序执行结果如下：

   ![](images/image-120.png)

    </TabItem>
    <TabItem value="SPI python" label="Python" default>
        可使用 Python 的 spidev 库进行 SPI 通信，spidev 库可在 RUBIK Pi 3 中使用下面命令进行安装：
        ```shell
        apt install python3-spidev
        ```
        以下代码示例，代码使用 SPI 总线进行数据收发通信：

        ```python
        import spidev

        def main():
            tx_buffer = [ord(char) for char in "hello world!"]
            rx_buffer = [0] * len(tx_buffer)

            try:
                spi = spidev.SpiDev()
                spi.open(12, 0)
                spi.max_speed_hz = 1000000

                rx_buffer = spi.xfer2(tx_buffer[:])
                print("tx_buffer:\n\r", ''.join(map(chr, tx_buffer)))
                print("rx_buffer:\n\r", ''.join(map(chr, rx_buffer)))

            except Exception as e:
                print(f"An error occurred: {e}")

            finally:
                if spi:
                    spi.close()

        if __name__ == "__main__":
            main()
        ```


        将 19 号引脚和 21 号引脚使用杜邦线短接，验证 SPI 总线通信，如下图所示：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155529-3.jpg)

        在魔方派 3 中运行如下命令：

        ```shell
         python3 spi.py
        ```

        程序执行结果如下：
        ![](images/image-118.png)

    </TabItem>
</Tabs>


### UART
<a id="UART"></a>

RUBIK Pi 3 适配了 WiringRP（基于高性能 GPIO 编程库 WiringPi），推荐使用 WiringRP 来控制 UART，和对 UART 编程。关于 WiringRP 详细信息可访问 https://github.com/rubikpi-ai/WiringRP 查看。

#### 引脚分布

下图是 RUBIK Pi 3 40-pin 连接器的引脚默认功能，其中大部分引脚和树梅派 40-pin 连接器引脚的默认功能兼容。

![](images/image-116.png)

:::note
>
> 8 号和 10 号引脚默认已设置配为 UART，设备节点为 */dev/ttyHS2*。
:::

下表是 40-pin 连接器支持的所有功能，图中蓝色字体表明默认功能。

![](images/image-117.png)


#### 使用 UART

<Tabs>
    <TabItem value="UART Shell" label="Shell 命令" default>
        在 RUBIK Pi 3 中 使用下面命令控制串口通信

        使用 stty 工具配置串口，如下将串口的输入速率和输出速率都设置为 115200，并关闭回显：

        ```shell
        stty -F /dev/ttyHS2 ispeed 115200 ospeed 115200
        stty -F /dev/ttyHS2 -echo
        ```

        在 RUBIK Pi 3 上开启两个终端，将 8 号引脚和 10 号引脚使用杜邦线短接，分别执行下面命令，接收端会回显发送端的内容：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ```shell
        echo "hello world!" > /dev/ttyHS2  # 发送端
        cat /dev/ttyHS2 # 接收端
        ```

        ![](images/20250314-155526.jpg)

    </TabItem>
    <TabItem value="UART WiringRP-c" label="WiringRP" default>
        WiringRP 库中提供了一系列的 API 函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP.
        ```shell
        sudo apt install wiringrp

        以下代码示例，使用UART进行数据收发通信：
        ```c
        #include <stdio.h>
        #include <string.h>
        #include <errno.h>

        #include <wiringPi.h>
        #include <wiringSerial.h>

        int main ()
        {
          int fd ;
          int count ;
          unsigned int nextTime ;

          if ((fd = serialOpen ("/dev/ttyHS2", 115200)) < 0)
          {
            fprintf (stderr, "Unable to open serial device: %s\n", strerror (errno)) ;
            return 1 ;
          }

          if (wiringPiSetup () == -1)
          {
            fprintf (stdout, "Unable to start wiringPi: %s\n", strerror (errno)) ;
            return 1 ;
          }


          char tx_buffer[] = "hello world!\n";
          for (count = 0 ; count < sizeof(tx_buffer) ; count++)
          {
            serialPutchar (fd, tx_buffer[count]) ;
            delay (3) ;
            printf ("%c", serialGetchar (fd)) ;
          }
          printf ("\n") ;

          return 0 ;
        }
        ```

    在 RUBIK Pi 3 中编译程序

    ```shell
    gcc uart.c -o uart -lwiringPi
    ```

     :::note
     若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
     :::

    将 8 号引脚和 10 号引脚使用杜邦线短接，验证串口通信，如下图所示：

    :::warning
    注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
    :::

    ![](images/20250314-155526-1.jpg)

    运行如下命令：

    ```shell
    ./uart
    ```

     程序执行结果如下：

     ![](images/image-115.png)


    </TabItem>
    <TabItem value="UART WiringRP-python" label="WiringRP-Python" default>
        WiringRP-Python 库中提供了一系列的 API 函数，用更少的逻辑实现控制。

        使用前需按下面方法安装 WiringRP-Python：

        1. 将魔方派公共个人软件档案（PPA）添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        sudo apt update
        ```
        2. 执行下面命令安装 WiringRP-Python.
        ```shell
        sudo apt install wiringrp-python
        ```
        以下代码示例，使用 UART 进行数据收发通信：
        ```python
        import wiringpi

        serial = wiringpi.serialOpen('/dev/ttyHS2', 115200)

        wiringpi.serialPuts(serial, "hello world")

        received_data = []
        c = wiringpi.serialGetchar(serial);
        received_data.append(chr(c))

        cnt = wiringpi.serialDataAvail(serial);
        for i in range(cnt):
            c = wiringpi.serialGetchar(serial);
            received_data.append(chr(c))

        print("Received:", received_data)

        wiringpi.serialClose(serial)
        ```

        将 8 号引脚和 10 号引脚使用杜邦线短接，验证串口通信，如下图所示：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155526-4.jpg)

        运行如下命令：

        ```shell
        python3 uart.py
        ```

        程序执行结果如下：
        ![](images/image-127.png)

    </TabItem>
    <TabItem value="UART C" label="C" default>
        以下代码示例，使用 UART 进行数据收发通信：

          ```c
          #include <stdio.h>
          #include <stdlib.h>
          #include <string.h>
          #include <fcntl.h>
          #include <termios.h>
          #include <unistd.h>

          int main() {
              int serial_port_num = 2;
              char serial_port[15];

              sprintf(serial_port,"/dev/ttyHS%d",serial_port_num);
              int serial_fd;

              serial_fd = open(serial_port, O_RDWR | O_NOCTTY);
              if (serial_fd == -1) {
                  perror("Failed to open serial port");
                  return 1;
              }

              struct termios tty;
              memset(&tty, 0, sizeof(tty));

              if (tcgetattr(serial_fd, &tty) != 0) {
                  perror("Error from tcgetattr");
                  return 1;
              }

              cfsetospeed(&tty, B9600);
              cfsetispeed(&tty, B9600);

              tty.c_cflag &= ~PARENB;
              tty.c_cflag &= ~CSTOPB;
              tty.c_cflag &= ~CSIZE;
              tty.c_cflag |= CS8;

              if (tcsetattr(serial_fd, TCSANOW, &tty) != 0) {
                  perror("Error from tcsetattr");
                  return 1;
              }

              char tx_buffer[] = "hello world!\n";
              ssize_t bytes_written = write(serial_fd, tx_buffer, sizeof(tx_buffer));

              if (bytes_written < 0) {
                  perror("Error writing to serial port");
                  close(serial_fd);
                  return 1;
              }
              printf("\rtx_buffer: \n %s ", tx_buffer);

              char rx_buffer[256];
              int bytes_read = read(serial_fd, rx_buffer, sizeof(rx_buffer));
              if (bytes_read > 0) {
                  rx_buffer[bytes_read] = '\0';
                  printf("\rrx_buffer: \n %s ", rx_buffer);
              } else {
                  printf("No data received.\n");
              }

              close(serial_fd);

              return 0;
            }

            ```

            在 RUBIK Pi 3 中编译程序

            ```shell
            gcc uart.c -o uart
            ```

            :::note
            若无 gcc 命令，可执行 `apt install gcc` 命令进行安装。
            :::

            将 8 号引脚和 10 号引脚使用杜邦线短接，验证串口通信，如下图所示：

            :::warning
            注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
            :::

            ![](images/20250314-155526-2.jpg)

            运行如下命令：

            ```shell
            ./uart
            ```

            程序执行结果如下：

            ![](images/image-184.png)
    </TabItem>
    <TabItem value="UART python" label="Python" default>
        可使用 Python 的 serial 库进行 UART 通信，可在 RUBIK Pi 3 中使用下面命令进行安装：

        ```shell
        apt install python3-serial
        ```

        以下代码示例，使用 UART 进行数据收发通信：

        ```python
        import serial
        import time

        with serial.Serial(
            "/dev/ttyHS2",
            baudrate=115200,
            bytesize=serial.EIGHTBITS,
            stopbits=serial.STOPBITS_ONE,
            parity=serial.PARITY_NONE,
            timeout=1,

        ) as uart3:
            uart3.write(b"Hello World!\n")
            buf = uart3.read(128)
            print("Raw data:\n", buf)
            data_strings = buf.decode("utf-8")
            print("Read {:d} bytes, printed as string:\n {:s}".format(len(buf), data_strings))
        ```

        将 *uart.py&#x20;*&#x4F20;输到  RUBIK Pi 3 中，如果使用 ADB 传输，命令如下：

        ```shell
        adb push uart.py /opt
        ```

        将 8 号引脚和 10 号引脚使用杜邦线短接，验证串口通信，如下图所示：

        :::warning
        注意引脚顺序，请勿将电源和地引脚短接，否则可能会造成板子损坏。
        :::

        ![](images/20250314-155526-3.jpg)

        运行如下命令：

        ```shell
        python3 uart.py
        ```

        程序执行结果如下：

        ![](images/image-183.png)

    </TabItem>
</Tabs>


## USB

通用串行总线 (USB) 是一种行业标准，允许在各种类型的电子设备之间进行数据交换和供电。该标准支持多种运行速度，例如 1.5 Mbps 低速、12 Mbps 全速、480 Mbps 高速以及 5 Gbps 超高速和 10 Gbps 超高速 Plus。

RUBIK Pi 3 拥有 4 个 USB 口：

* 两个 USB 3.0 A 口，只能作为主机模式使用，如下图 7。

* 一个 USB 2.0 A 口，可以作为主机或设备模式使用，如下图 6。

* 一个 USB 3.1 Gen 1 C 口，可以作为主机或设备模式（常用于 ADB），以及 DP 显示使用，如下图 5。

![](images/image-125.png)

### USB 接口功能验证

    <Tabs>
    <TabItem value="USB CAM" label="USB 摄像头" default>

    魔方派 3 设备为符合 USB 视频类（UVC）标准的 USB 网络摄像头提供驱动程序支持。Linux 内核的 `uvcvideo` 驱动程序支持摄像头。有关 `uvcvideo` 驱动程序的更多信息，请参阅 https://www.kernel.org/doc/html/v4.19/media/v4l-drivers/uvcvideo.html。

    `uvcvideo` 驱动程序将这类摄像头作为 V4L2 视频设备（可通过字符设备节点（如 /dev/videoX）进行访问）公开。

    在用户空间中，应用程序可以使用 `v4l2src` GStreamer 插件管理 USB 摄像头，该插件与 Qualcomm 智能多媒体 SDK (QIM SDK) 捆绑在一起。此外，Yavta（又一个 V4L2 测试应用程序）等程序可以直接与 V4L2（Video4Linux2）接口交互，以测试和控制摄像头设备。

    安装 Yavta

    ```shell
    sudo apt install yavta
    ```
    **前提条件：获取图像格式大小**

    要通过 Yavta 或 GStreamer 配置 USB 摄像头，必须执行以下步骤。
    1. 要了解枚举详细信息，应插入 USB 摄像头并运行以下命令。
    ```shell
    lsusb
    ```

    随即显示以下输出。

    ```
    Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
    Bus 001 Device 003: ID 1bcf:0215 Sunplus Innovation Technology Inc. 4K AutoFocus Webcam
    Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
    Bus 002 Device 002: ID 0b95:1790 ASIX Electronics Corp. AX88179 Gigabit Ethernet
    Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
    ```

    2. USB 摄像头插入前后，在魔方派 3 的终端，执行如下命令，根据两次结果的差异可以确定 USB 摄像头视频节点。
    ```shell
    ls /dev/video*
    ```
    示例输出：
    ```
    root@rubikpi:/sys/bus/pci# ls /dev/video*
    /dev/video0  /dev/video1  /dev/video32  /dev/video33
    root@rubikpi:/sys/bus/pci# ls /dev/video*
    /dev/video0  /dev/video1  /dev/video2  /dev/video3  /dev/video32  /dev/video33
    ```
    如上所示，USB 摄像头的节点为 *video2* 和 *video3*。

    3. 要使用 Yavta 查看支持的输出格式和大小，应运行以下命令：
    ```shell
    yavta /dev/video2 --enum-formats
    ```
    随即显示以下输出。

    ```
    Device /dev/video3 opened.
    Device `4K AutoFocus Webcam: 4K AutoFoc' on `usb-0000:01:00.0-1' (driver 'uvcvideo') supports meta-d.
    - Available formats:
            Format 0: UVCH (48435655)
            Type: Meta-data capture (13)
            Name: UVC Payload Header Metadata

    Meta-data format: UVCH (48435655) buffer size 10240
    ubuntu@rubikpi:~$ yavta /dev/video2 --enum-formats
    Device /dev/video2 opened.
    Device `4K AutoFocus Webcam: 4K AutoFoc' on `usb-0000:01:00.0-1' (driver 'uvcvideo') supports video,.
    - Available formats:
            Format 0: MJPEG (47504a4d)
            Type: Video capture (1)
            Name: Motion-JPEG
            Frame size: 1920x1080 (1/30, 1/30)
            Frame size: 1280x720 (1/30)
            Frame size: 1600x900 (1/30)
            Frame size: 2304x1296 (1/30)
            Frame size: 2560x1440 (1/30)
            Frame size: 2688x1512 (1/30)
            Frame size: 3840x2160 (1/25)
            Frame size: 640x360 (1/30)
            Frame size: 800x450 (1/30)
            Frame size: 848x480 (1/30)
            Frame size: 960x540 (1/30)
            Frame size: 1024x576 (1/30)
            Frame size: 640x480 (1/30)
            Frame size: 800x600 (1/30)
            Frame size: 960x720 (1/30)
            Frame size: 1024x768 (1/30)
            Frame size: 1280x960 (1/30)
            Frame size: 1600x1200 (1/30)
            Frame size: 2048x1536 (1/30)
            Frame size: 2592x1944 (1/30)
            Frame size: 1920x1080 (1/30, 1/30)

            Format 1: YUYV (56595559)
            Type: Video capture (1)
            Name: YUYV 4:2:2
            Frame size: 1920x1080 (1/5, 1/5)
            Frame size: 1280x720 (1/10)
            Frame size: 1600x900 (1/5)
            Frame size: 640x360 (1/30)
            Frame size: 800x450 (1/20)
            Frame size: 848x480 (1/20)
            Frame size: 960x540 (1/20)
            Frame size: 1024x576 (1/15)
            Frame size: 640x480 (1/30)
            Frame size: 800x600 (1/20)
            Frame size: 960x720 (1/15)
            Frame size: 1024x768 (1/10)
            Frame size: 1280x960 (2/15)
            Frame size: 1600x1200 (1/5)
            Frame size: 1920x1080 (1/5, 1/5)

    Video format: MJPEG (47504a4d) 1920x1080 (stride 0) field none buffer size 4147200
    ```
    4. 从第 3 步的显示结果中选择所需的图像格式和大小。

    **使用 Yavta 配置 USB 摄像头**

    前提条件：USB 摄像头输出格式和大小已确定。

    请运行以下命令，以便选择 1920x1080 输出尺寸和 30 fps 的 MJPEG 格式，在 /tmp/ 下采集 10 帧，文件名为 testmjpeg-00000*.bin。

    ```shell
    yavta -f MJPEG -s 1920x1080 -t 1/30 -c10 -F/tmp/testmjpeg /dev/video2
    ```
    随即显示以下输出。
    ```
    Device /dev/video2 opened.
    Device `4K AutoFocus Webcam: 4K AutoFoc' on `usb-0000:01:00.0-1' (driver 'uvcvideo') supports video, capture, without mplanes.
    Video format set: MJPEG (47504a4d) 1920x1080 (stride 0) field none buffer size 4147200
    Video format: MJPEG (47504a4d) 1920x1080 (stride 0) field none buffer size 4147200
    Current frame rate: 1/30
    Setting frame rate to: 1/30
    Frame rate set: 1/30
    8 buffers requested.
    length: 4147200 offset: 0 timestamp type/source: mono/SoE
    Buffer 0/0 mapped at address 0xffffa5e5b000.
    length: 4147200 offset: 32768 timestamp type/source: mono/SoE
    Buffer 1/0 mapped at address 0xffffa5a66000.
    length: 4147200 offset: 65536 timestamp type/source: mono/SoE
    Buffer 2/0 mapped at address 0xffffa5671000.
    length: 4147200 offset: 98304 timestamp type/source: mono/SoE
    Buffer 3/0 mapped at address 0xffffa527c000.
    length: 4147200 offset: 131072 timestamp type/source: mono/SoE
    Buffer 4/0 mapped at address 0xffffa4e87000.
    length: 4147200 offset: 163840 timestamp type/source: mono/SoE
    Buffer 5/0 mapped at address 0xffffa4a92000.
    length: 4147200 offset: 196608 timestamp type/source: mono/SoE
    Buffer 6/0 mapped at address 0xffffa469d000.
    length: 4147200 offset: 229376 timestamp type/source: mono/SoE
    Buffer 7/0 mapped at address 0xffffa42a8000.
    0 (0) [-] none 0 115283 B 53.095060 53.647782 244.260 fps ts mono/SoE
    1 (1) [-] none 1 115277 B 53.647091 53.679768 1.811 fps ts mono/SoE
    2 (2) [-] none 2 115376 B 53.683085 53.715810 27.782 fps ts mono/SoE
    3 (3) [-] none 3 115545 B 53.715105 53.747738 31.230 fps ts mono/SoE
    4 (4) [-] none 4 117998 B 53.747096 53.783769 31.259 fps ts mono/SoE
    5 (5) [-] none 5 117962 B 53.783089 53.815715 27.783 fps ts mono/SoE
    6 (6) [-] none 6 118127 B 53.815088 53.847740 31.251 fps ts mono/SoE
    7 (7) [-] none 7 118027 B 53.847099 53.883764 31.239 fps ts mono/SoE
    8 (0) [-] none 8 119080 B 53.883084 53.915721 27.789 fps ts mono/SoE
    9 (1) [-] none 9 119399 B 53.915093 53.947736 31.241 fps ts mono/SoE
    Captured 10 frames in 0.856770 seconds (11.671741 fps, 1368014.420968 B/s).
    8 buffers released.

    ```
    请运行以下命令，以便选择 1280x960 输出尺寸、15 fps 的 YUV 格式，在 /tmp/ 下采集 10 帧，生成的文件名为 testyuv-00000*.bin。

    ```shell
    yavta -f YUYV -s 1280x720 -t 1/15 -c10 -F/tmp/testyuv /dev/video2
    ```
    随即显示以下输出。
    ```
    Device /dev/video2 opened.
    Device `4K AutoFocus Webcam: 4K AutoFoc' on `usb-0000:01:00.0-1' (driver 'uvcvideo') supports video,.
    Video format set: YUYV (56595559) 1280x720 (stride 2560) field none buffer size 1843200
    Video format: YUYV (56595559) 1280x720 (stride 2560) field none buffer size 1843200
    Current frame rate: 1/10
    Setting frame rate to: 1/15
    Frame rate set: 1/10
    8 buffers requested.
    length: 1843200 offset: 0 timestamp type/source: mono/SoE
    Buffer 0/0 mapped at address 0xffff966ce000.
    length: 1843200 offset: 32768 timestamp type/source: mono/SoE
    Buffer 1/0 mapped at address 0xffff9650c000.
    length: 1843200 offset: 65536 timestamp type/source: mono/SoE
    Buffer 2/0 mapped at address 0xffff9634a000.
    length: 1843200 offset: 98304 timestamp type/source: mono/SoE
    Buffer 3/0 mapped at address 0xffff96188000.
    length: 1843200 offset: 131072 timestamp type/source: mono/SoE
    Buffer 4/0 mapped at address 0xffff95fc6000.
    length: 1843200 offset: 163840 timestamp type/source: mono/SoE
    Buffer 5/0 mapped at address 0xffff95e04000.
    length: 1843200 offset: 196608 timestamp type/source: mono/SoE
    Buffer 6/0 mapped at address 0xffff95c42000.
    length: 1843200 offset: 229376 timestamp type/source: mono/SoE
    Buffer 7/0 mapped at address 0xffff95a80000.
    0 (0) [-] none 0 1843200 B 364.737849 364.966754 2.174 fps ts mono/SoE
    1 (1) [-] none 1 1843200 B 364.966042 365.066785 4.382 fps ts mono/SoE
    2 (2) [-] none 2 1843200 B 365.066087 365.166812 9.996 fps ts mono/SoE
    3 (3) [-] none 3 1843200 B 365.166149 365.266862 9.994 fps ts mono/SoE
    4 (4) [-] none 4 1843200 B 365.266205 365.366929 9.994 fps ts mono/SoE
    5 (5) [-] none 5 1843200 B 365.366266 365.466985 9.994 fps ts mono/SoE
    6 (6) [-] none 6 1843200 B 365.466326 365.567108 9.994 fps ts mono/SoE
    7 (7) [-] none 7 1843200 B 365.566381 365.667099 9.995 fps ts mono/SoE
    8 (0) [-] none 8 1843200 B 365.666440 365.767150 9.994 fps ts mono/SoE
    9 (1) [-] none 9 1843200 B 365.766496 365.867212 9.994 fps ts mono/SoE
    Captured 10 frames in 1.589346 seconds (6.291895 fps, 11597220.863435 B/s).
    8 buffers released.
    ```

    **使用 Qualcomm IM SDK 中的 GStreamer 配置 USB 摄像头**

    Qualcomm IM SDK 采用开源多媒体框架 [GStreamer](https://gstreamer.freedesktop.org/) 公开了多媒体和机器学习这两个领域简洁的 API 和易用的插件。有关安装 Qualcomm IM SDK 的信息，请参阅 [快速开始](./1.Quick Start.md#runmediaapp) 部分。

Qualcomm IM SDK 包含 v4l2src 插件，该插件允许以选定的格式从 USB 摄像头进行输入。waylandsink 插件负责在 Wayland 显示界面上渲染视频输出。

    前提条件：USB 摄像头输出格式和大小已确定。

    1. 要设置 Wayland 显示界面的环境变量，在魔方派 3 终端中运行以下命令。
    ```shell
    export XDG_RUNTIME_DIR=/dev/socket/weston && export WAYLAND_DISPLAY=wayland-1
    ```
    2.使用 GStreamer 命令将摄像头拍摄的视频流传输到 UI。确保已设置合适的设备 ID (*/dev/videoX*)，并根据检测到的 USB 摄像头选择正确的格式。
    :::note
    在 GStreamer 中，YUYV 颜色格式被称为 YUY2。因此，您必须在设置管道时指定 YUYV 格式并在 caps 过滤器中使用 **YUY2**。
    :::
        * 对于 720p，运行以下命令：
        ```shell
        gst-launch-1.0 -e v4l2src io-mode=dmabuf-import device="/dev/video0" ! video/x-raw,format=YUY2,width=1280,height=720,framerate=10/1 ! waylandsink fullscreen=true
        ```
        随即显示以下输出。
        ```
        Y2,width=1280,height=720,framerate=10/1 ! waylandsink fullscreen=true
        Setting pipeline to PAUSED ...
        I/Adreno-UNKNOWN (1985,1985): <ReadGpuID:357>: Reading chip ID through GSL
        GBM_INFO::msmgbm_mapper(262)::gbm mapper instantiated
        gbm_create_device(224): Info: backend name is: msm_drm
        Pipeline is live and does not need PREROLL ...
        Pipeline is PREROLLED ...
        Setting pipeline to PLAYING ...
        New clock: GstSystemClock
        gbm_create_device(224): Info: backend name is: msm_drm
        GBM_ERR::msmgbm_bo_create(870)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for data fd errono: 22 (Invalid argument) drm fd: 24 data fd: 26
         GBM_ERR::msmgbm_bo_create(923)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for metadata fd errono: 22 (Invalid argument) drm fd: 24 metadata fd: 27
        GBM_ERR::msmgbm_bo_create(870)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for data fd errono: 22 (Invalid argument) drm fd: 24 data fd: 29
        GBM_ERR::msmgbm_bo_create(923)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for metadata fd errono: 22 (Invalid argument) drm fd: 24 metadata fd: 30
        GBM_ERR::msmgbm_bo_create(870)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for data fd errono: 22 (Invalid argument) drm fd: 24 data fd: 32
        GBM_ERR::msmgbm_bo_create(923)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for metadata fd errono: 22 (Invalid argument) drm fd: 24 metadata fd: 33
        GBM_ERR::msmgbm_bo_create(870)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for data fd errono: 22 (Invalid argument) drm fd: 24 data fd: 35
        GBM_ERR::msmgbm_bo_create(923)::DRM_IOCTL_PRIME_FD_TO_HANDLE failed for metadata fd errono: 22 (Invalid argument) drm fd: 24 metadata fd: 36
        Redistribute latency...
        0:00:47.7 / 99:99:99.
        ```
        * 对于 1080p，运行以下命令：
        ```shell
        gst-launch-1.0 -e v4l2src io-mode=dmabuf-import device="/dev/video0" ! video/x-raw,format=YUY2,width=1920,height=1080,framerate=5/1 ! waylandsink fullscreen=true
        ```
    </TabItem>

    <TabItem value="USB Custom" label="自定义 USB 设备" default>
    自定义 USB 设备（device 模式）,在魔方派中，只有 USB 2.0 A 口和 USB 3.1 C 口支持, 下面以 USB 3.1 C 口为例。

    **具有 diag 和 ADB 接口的 USB 复合设备的 shell 脚本示例**
    ```shell
    cd /sys/kernel/config/usb_gadget/adb
    echo on > /sys/bus/platform/devices/a600000.usb/power/control
    echo "" > UDC
    mkdir functions/ffs.diag
    echo "QCOM" > strings/0x409/manufacturer
    echo 0x05c6 > idVendor
    echo 0x901d > idProduct
    echo "Diag_ADB" > configs/c.1/strings/0x409/configuration

    if [ ! -d /dev/ffs-diag ]; then
    mkdir -p /dev/ffs-diag
    fi
    if [ ! -e /dev/ffs-diag/ep0 ]; then
    mount -o uid=2000,gid=2000 -t functionfs diag /dev/ffs-diag
    fi

    /usr/bin/diag-router &

    cd configs/c.1
    rm -r ffs.usb0
    ln -s ../../functions/ffs.diag f1
    ln -s ../../functions/ffs.usb0 f2
    cd ../../ udcname=`ls -1 /sys/class/udc | head -n 1`
    echo $udcname > UDC
    echo auto > /sys/bus/platform/devices/a600000.usb/power/control
    ```

    **模拟 U 盘**

    在魔方派 3 中执行如下操作，将魔方派模拟为一个 2G 的 U 盘。
    ```shell
    sudo -i
    cd /sys/kernel/config/usb_gadget/  #在串口终端登录或在 Terminal 应用中，执行下面命令
    mkdir g1
    cd g1
    mkdir functions/mass_storage.0
    dd if=/dev/zero of=/tmp/test.iso bs=1M count=2048  #创建大小为2G的U盘空间
    mkfs.ext4 /tmp/test.iso
    echo "/tmp/test.iso" > functions/mass_storage.0/lun.0/file
    mkdir configs/c.1
    ln -s functions/mass_storage.0/ configs/c.1/f3
    mount -t debugfs none /sys/kernel/debug/

    echo device > /sys/kernel/debug/usb/8c00000.usb/qcom_usb2_0_mode  #将USB切换为device模式
    echo 8c00000.usb > UDC #连接USB线到主机，U盘被识别 可在U盘内写入和写出文件

    echo host > /sys/kernel/debug/usb/8c00000.usb/qcom_usb2_0_mode  #拔掉USB线，切换为主机模式
    ```

    </TabItem>
</Tabs>

### USB 调试

本节提供有关获取调试日志的各种方法的信息。调试方式有 `regdumps` 、调试 `ftraces` 、 `configfs` 节点等。在调试与进入/退出低功耗模式、SMMU 故障、无时钟访问相关的问题时，可通过上述日志查看事件和控制器状态的详细信息。

:::note
下面命令需切换到 root 用户：
>
> 执行 `sudo passwd root` 命令根据提示修改 root 帐号密码，使用 `su root` 命令切换到 root 用户。
:::

* USB 2.0 Type-A 设备路径：*&#x20;/sys/devices/platform/soc@0/**8c00000**.usb/xhci-hcd.1.auto/usb3/*

* USB 3.0 Type-A 设备路径：

  * */sys/devices/platform/soc@0/**1c00000**.pci/pci0000:00/0000:00:00.0/0000:**01:00.0**/usb1*

  * */sys/devices/platform/soc@0/**1c00000**.pci/pci0000:00/0000:00:00.0/0000:**01:00.0**/usb2*

* USB 3.1 Type-C 设备路径：*/sys/devices/platform/soc@0/**a600000**.usb*&#x20;

#### USB 跟踪

使用 `debugfs` 跟踪可以更加深入地了解 USB 线上发生的每一个事务。如需查看跟踪列表，可运行以下命令。

:::warning
>
> 确保已挂载 `debugfs`。如果尚未挂载，可运行以下命令来挂载 `debugfs`:
>
> `mount -t debugfs none /sys/kernel/debug`
:::

```shell
ls /sys/kernel/debug/tracing/events/dwc3
```

以下是可用于验证 xHCI/gadget 协议栈/USB Type-C 连接器系统软件接口 (UCSI) 中的数据传输的跟踪。

```shell
dwc3_alloc_request  dwc3_event              dwc3_gadget_generic_cmd  enable
dwc3_complete_trb   dwc3_free_request       dwc3_gadget_giveback     filter
dwc3_ctrl_req       dwc3_gadget_ep_cmd      dwc3_prepare_trb
dwc3_ep_dequeue     dwc3_gadget_ep_disable  dwc3_readl
dwc3_ep_queue       dwc3_gadget_ep_enable   dwc3_writel
```

要列出 xHCI/主机控制器驱动程序 (HCD) 中的跟踪数据，请运行以下命令。

```shell
ls /sys/kernel/debug/tracing/events/xhci-hcd
```

以下是可用于验证 xHCI/HCD 中数据传输的跟踪。

```shell
enable                            xhci_handle_cmd_config_ep
filter                            xhci_handle_cmd_disable_slot
  xhci_add_endpoint                 xhci_handle_cmd_reset_dev
  xhci_address_ctrl_ctx             xhci_handle_cmd_reset_ep
  xhci_address_ctx                  xhci_handle_cmd_set_deq
  xhci_alloc_dev                    xhci_handle_cmd_set_deq_ep
  xhci_alloc_virt_device            xhci_handle_cmd_stop_ep
  xhci_configure_endpoint           xhci_handle_command
  xhci_configure_endpoint_ctrl_ctx  xhci_handle_event
  xhci_dbc_alloc_request            xhci_handle_port_status
  xhci_dbc_free_request             xhci_handle_transfer
  xhci_dbc_gadget_ep_queue          xhci_hub_status_data
  xhci_dbc_giveback_request         xhci_inc_deq
  xhci_dbc_handle_event             xhci_inc_enq
  xhci_dbc_handle_transfer          xhci_queue_trb
  xhci_dbc_queue_request            xhci_ring_alloc
  xhci_dbg_address                  xhci_ring_ep_doorbell
  xhci_dbg_cancel_urb               xhci_ring_expansion
  xhci_dbg_context_change           xhci_ring_free
  xhci_dbg_init                     xhci_ring_host_doorbell
  xhci_dbg_quirks                   xhci_setup_addressable_virt_device
  xhci_dbg_reset_ep                 xhci_setup_device
  xhci_dbg_ring_expansion           xhci_setup_device_slot
  xhci_discover_or_reset_device     xhci_stop_device
  xhci_free_dev                     xhci_urb_dequeue
  xhci_free_virt_device             xhci_urb_enqueue
  xhci_get_port_status              xhci_urb_giveback
  xhci_handle_cmd_addr_dev
```

请运行以下命令，以便列出 USB 视频类 (UVC) gadget 驱动程序的可用事件。

```shell
ls /sys/kernel/debug/tracing/events/gadget
```

随即显示以下输出。

```shell
enable                      usb_gadget_activate
  filter                      usb_gadget_clear_selfpowered
  usb_ep_alloc_request        usb_gadget_connect
  usb_ep_clear_halt           usb_gadget_deactivate
  usb_ep_dequeue              usb_gadget_disconnect
  usb_ep_disable              usb_gadget_frame_number
  usb_ep_enable               usb_gadget_giveback_request
  usb_ep_fifo_flush           usb_gadget_set_remote_wakeup
  usb_ep_fifo_status          usb_gadget_set_selfpowered
  usb_ep_free_request         usb_gadget_vbus_connect
  usb_ep_queue                usb_gadget_vbus_disconnect
  usb_ep_set_halt             usb_gadget_vbus_draw
  usb_ep_set_maxpacket_limit  usb_gadget_wakeup
  usb_ep_set_wedge
```

如需列出 UCSI 驱动程序中的可用事件，可运行以下命令。

```shell
ls /sys/kernel/debug/tracing/events/ucsi
```

随即显示以下输出。

```shell
enable  ucsi_connector_change  ucsi_register_port  ucsi_run_command
filter  ucsi_register_altmode  ucsi_reset_ppm
```

#### USB 寄存器打印

USB `debugfs` 提供以下信息，下面以 Type-C 接口为例。

* 工作模式

  ```shell
  cat /sys/kernel/debug/usb/a600000.usb/mode # Type-C 接口
  ```

  :::note
  >
  > USB 2.0 Type-A 的工作模式`cat /sys/kernel/debug/usb/8c00000.usb/qcom_usb2_0_mode`
  :::

  示例输出：

  ```shell
  device
  ```

* 设备模式下所有端点的状态和传输环形缓冲区 (TRB) 队列。

* 当前链路状态。

  ```shell
  cat /sys/kernel/debug/usb/a600000.usb/link_state
  ```

  示例输出&#x20;

  ```shell
  Sleep
  ```

* 列出处理器 (LSP) dump。

  ```shell
  cat /sys/kernel/debug/usb/a600000.usb/lsp_dump
  ```

  示例输出：

  ```shell
  GDBGLSP[0] = 0x40000000
  GDBGLSP[1] = 0x00003a80
  GDBGLSP[2] = 0x38200000
  GDBGLSP[3] = 0x00802000
  GDBGLSP[4] = 0x126f1000
  GDBGLSP[5] = 0x3a800018
  GDBGLSP[6] = 0x00000a80
  GDBGLSP[7] = 0xfc03f14a
  GDBGLSP[8] = 0x0b803fff
  GDBGLSP[9] = 0x00000000
  GDBGLSP[10] = 0x000000f8
  GDBGLSP[11] = 0x000000f8
  GDBGLSP[12] = 0x000000f8
  GDBGLSP[13] = 0x000000f8
  GDBGLSP[14] = 0x000000f8
  GDBGLSP[15] = 0x000000f8
  ```

```shell
ls /sys/kernel/debug/usb/a600000.usb
```

示例输出：

```shell
ep0in    ep11out  ep14in   ep1out  ep4in   ep6out  ep9in       regdump
ep0out   ep12in   ep14out  ep2in   ep4out  ep7in   ep9out      testmode
ep10in   ep12out  ep15in   ep2out  ep5in   ep7out  link_state
ep10out  ep13in   ep15out  ep3in   ep5out  ep8in   lsp_dump
ep11in   ep13out  ep1in    ep3out  ep6in   ep8out  mode
```

`regdump` 命令提供以下寄存器的寄存器空间的当前状态：&#x20;

* 设备模式的寄存器，例如 DCTL、DSTS 和 DCFG

* 全局寄存器，例如 GCTL 和 GSTS

```shell
cd /sys/kernel/debug/usb/a600000.usb
cat regdump
```

示例输出：

```shell
GSBUSCFG0 = 0x2222000e
GSBUSCFG1 = 0x00001700
GTXTHRCFG = 0x00000000
GRXTHRCFG = 0x00000000
GCTL = 0x00102000
GEVTEN = 0x00000000
GSTS = 0x7e800000
GUCTL1 = 0x810c1802
GSNPSID = 0x5533330a
GGPIO = 0x00000000
GUID = 0x00060500
GUCTL = 0x0d00c010
GBUSERRADDR0 = 0x00000000
GBUSERRADDR1 = 0x00000000
GPRTBIMAP0 = 0x00000000
GPRTBIMAP1 = 0x00000000
GHWPARAMS0 = 0x4020400a
GDBGFIFOSPACE = 0x00420000
GDBGLTSSM = 0x41090658
GDBGBMU = 0x20300000
GPRTBIMAP_HS0 = 0x00000000
GPRTBIMAP_HS1 = 0x00000000
GPRTBIMAP_FS0 = 0x00000000
GPRTBIMAP_FS1 = 0x00000000
GUCTL2 = 0x0198440d
VER_NUMBER = 0x00000000
VER_TYPE = 0x00000000
GUSB2PHYCFG(0) = 0x00002400
GUSB2I2CCTL(0) = 0x00000000
GUSB2PHYACC(0) = 0x00000000
GUSB3PIPECTL(0) = 0x030e0002
GTXFIFOSIZ(0) = 0x00000042
GRXFIFOSIZ(0) = 0x00000305
GEVNTADRLO(0) = 0xfffff000
GEVNTADRHI(0) = 0x0000000f
GEVNTSIZ(0) = 0x00001000
GEVNTCOUNT(0) = 0x00000000
GHWPARAMS8 = 0x000007ea
GUCTL3 = 0x00010000
GFLADJ = 0x8c80c8a0
DCFG = 0x00cc08b4
DCTL = 0x8cf00a00
DEVTEN = 0x00000257
DSTS = 0x008a5200
DGCMDPAR = 0x00000000
DGCMD = 0x00000000
DALEPENA = 0x0000000f
DEPCMDPAR2(0) = 0x00000000
DEPCMDPAR1(0) = 0xffffe000
DEPCMDPAR0(0) = 0x0000000f
DEPCMD(0) = 0x00000006
OCFG = 0x00000000
OCTL = 0x00000000
OEVT = 0x00000000
OEVTEN = 0x00000000
OSTS = 0x00000000
```

#### 主机 sysfs 查询

要查看总线详细信息，请运行以下命令。

```shell
lsusb
```

示例输出：

```shell
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 002: ID 03f0:134a HP, Inc Optical Mouse
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

请运行以下命令，以便列出当前目录的内容。

```shell
cd /sys/bus/usb/devices/
ls
```

示例输出：

```shell
1-0:1.0  1-1  1-1:1.0  2-0:1.0  usb1  usb2
```

要查看有关 USB 设备的详细信息，请运行以下命令。

```shell
cat /sys/kernel/debug/usb/devices
```

示例输出：

```shell
T:  Bus=01 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=480  MxCh= 1
B:  Alloc=  0/800 us ( 0%), #Int=  0, #Iso=  0
D:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=01 MxPS=64 #Cfgs=  1
P:  Vendor=1d6b ProdID=0002 Rev= 6.05
S:  Manufacturer=Linux 6.5.0-rc4 xhci-hcd
S:  Product=xHCI Host Controller
S:  SerialNumber=xhci-hcd.0.auto
C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=256ms

T:  Bus=01 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=1.5  MxCh= 0
D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=03f0 ProdID=134a Rev= 1.00
S:  Manufacturer=PixArt
S:  Product=HP USB Optical Mouse
C:* #Ifs= 1 Cfg#= 1 Atr=a0 MxPwr=100mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=usbhid
E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=10ms

T:  Bus=02 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=5000 MxCh= 1
B:  Alloc=  0/800 us ( 0%), #Int=  0, #Iso=  0
D:  Ver= 3.00 Cls=09(hub  ) Sub=00 Prot=03 MxPS= 9 #Cfgs=  1
P:  Vendor=1d6b ProdID=0003 Rev= 6.05
S:  Manufacturer=Linux 6.5.0-rc4 xhci-hcd
S:  Product=xHCI Host Controller
S:  SerialNumber=xhci-hcd.0.auto
C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=256ms
```

## 相机串行接口（CSI）

目前 RUBIK Pi 3 已经兼容树莓派官方的两款摄像头。下表显示了每个摄像头模块支持的分辨率：

| 分辨率         | 宽高比  | IMX477 | IMX219 |
| ----------- | ---- | ------ | ------ |
| 4056 x 3040 | 4:3  | 是      | 否      |
| 4608 x 2592 | 16:9 | 否      | 否      |
| 3280 x 2464 | 4:3  | 否      | 是      |
| 1920 x 1080 | 16:9 | 是      | 否      |
| 1632 x 1224 | 4:3  | 否      | 是      |

* Raspberry Pi High Quality Camera（IMX477/M12 Mount）[购买链接](https://www.raspberrypi.com/products/raspberry-pi-high-quality-camera/)

  ![](images/20250314-155508.jpg)

* Raspberry Pi Camera Module 2 (IMX219) [购买链接](https://www.raspberrypi.com/products/camera-module-v2/)

  :::note
  >
  > 目前 RUBIK Pi 3 暂时只支持标准版 Module 2 摄像头，不支持广角（Wide）、夜光（NoIR）版本。
  :::

### 摄像头排线安装
<a id="cameracable"></a>

RUBIK Pi 3 支持的摄像头 FPC 为 22 pin，0.5mm 间距，厚度 0.3±0.05mm。可以兼容 [树莓派 5 同规格摄像头FPC](https://www.raspberrypi.com/products/camera-cable/)。

:::danger
>
> 严禁在板子未断电的情况下插拔摄像头，否则非常容易烧坏摄像头模组。
:::

![](images/20250314-155515.jpg)

1. 向上拉开连接器的锁扣部分：

   ![](images/20250314-155519.jpg)

2. 插入 FPC，注意接触面朝向板内：

   ![](images/20250314-155503.jpg)

3. 按下锁扣，确认 FPC 稳定没有松动：

   ![](images/20250314-155500.jpg)

### 摄像头使用方法

将摄像头插入，下图 13 和 14 处

![](images/image-124.png)

如下为实物连接图：

![](images/20250314-155452.jpg)

* 前提准备
    1. 将 Qualcomm 和魔方派公共个人软件包档案 (PPA) 添加到您的魔方派 3 Ubuntu 软件源。
        ```shell
        sudo add-apt-repository ppa:ubuntu-qcom-iot/qcom-noble-ppa
        sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
        ```
    2. 安装摄像头软件
        ```shell
        sudo apt update
        sudo apt install -y qcom-ib2c qcom-camera-server qcom-camx
        sudo apt install -y rubikpi3-cameras
        sudo apt install gstreamer1.0-qcom-sample-apps
        sudo chmod -R 777 /opt
        sudo mkdir -p /var/cache/camera/
        sudo touch /var/cache/camera/camxoverridesettings.txt
        echo  enableNCSService=FALSE >> /var/cache/camera/camxoverridesettings.txt
        ```
    3. 重启。
        ```shell
        sudo reboot
        ```
* 拍照测试
    ```shell
    # CAM1, 生成物为 /opt/img0_123.jpg
    gst-launch-1.0 -e qtiqmmfsrc camera=0 ! video/x-raw,format=NV12,width=1280,height=720,framerate=30/1 ! queue ! jpegenc ! queue ! multifilesink location=/opt/img0_%d.jpg max-files=5

    # CAM2, 生成物为 /opt/img1_123.jpg
    gst-launch-1.0 -e qtiqmmfsrc camera=1 ! video/x-raw,format=NV12,width=1280,height=720,framerate=30/1 ! queue ! jpegenc ! queue ! multifilesink location=/opt/img1_%d.jpg max-files=5
    ```


### 摄像头故障排除

如果摄像头无法显示或捕捉图像，请检查以下内容：

1. 检查摄像头模块连接

   请参阅 [摄像头排线安装](#cameracable)。

2. &#x20;使用以下命令收集日志

   ```shell
   journalctl -f > /opt/log.txt
   ```

   在日志中搜索 "probe success" 。Probe success 意味着摄像头模块已通电并响应 I2C 控制。如果特定传感器没有 "probe success" 日志，则可能是柔性电缆连接或摄像头模块的问题。

   以下日志指示探测到一个 IMX477：

   ```shell
   [   80.645992] CAM_INFO: CAM-SENSOR: cam_sensor_driver_cmd: 939: Probe success,slot:7,slave_addr:0x34,sensor_id:0x477, is always on: 0
   ```

3. 检查摄像头传感器驱动程序命令

   使用 `journalctl -f > /opt/log.txt`命令收集日志并搜索 "cam\_sensor\_driver\_cmd" 。"CAM\_START\_DEV Success" 表示摄像头传感器流式传输开始。"CAM\_STOP\_DEV Success" 表示摄像头传感器流式传输停止。例如：

   ```shell

   start:
   [   81.172814] CAM_INFO: CAM-SENSOR: cam_sensor_driver_cmd: 1129: CAM_START_DEV Success, sensor_id:0x477,sensor_slave_addr:0x34
   stop:
   [   88.905241] CAM_INFO: CAM-SENSOR: cam_sensor_driver_cmd: 1157: CAM_STOP_DEV Success, sensor_id:0x477,sensor_slave_addr:0x34
   ```

4. 检查传感器流式传输

   启用 CSID SOF/EOF IRQ 日志，随后执行摄像头出流命令

   ```shell
   mount -o rw,remount /usr
   mount -t debugfs none /sys/kernel/debug/
   echo 0x8 > /sys/module/camera/parameters/debug_mdl
   echo 3 >/sys/kernel/debug/camera_ife/ife_csid_debug
   echo 1 > /sys/kernel/tracing/tracing_on
   echo 1 > /sys/kernel/tracing/events/camera/cam_log_debug/enable
   echo 2 > /sys/module/camera/parameters/debug_type
   cat /sys/kernel/tracing/trace_pipe > trace.txt

   ```

   捕获的日志有助于提供有关 SOF 和 EOF 的详细信息。在日志 "trace.txt" 中搜索 "irq\_status\_ipp"。

   * BIT12(0x1000)表示 SOF 数据包

   * BIT9(0x200)表示 EOF 数据包。

   日志如下所示：

   ```shell
   <idle>-0       [000] d.h1. 19287.546764: cam_log_debug:
   CAM_DBG: CAM-ISP: cam_ife_csid_irq: 4996: irq_status_ipp = 0x1110 cam-server-25604     [000] dNH.. 19287.561705: cam_log_debug:
   CAM_DBG: CAM-ISP: cam_ife_csid_irq: 4996: irq_status_ipp = 0xee8
   ```

## HDMI OUT

RUBIK Pi 3 的 HDMI 接口为下图 9。

RUBIK Pi 3 HDMI 参数信息：

* HDMI 1.4

* 最高 3840 x 2160 分辨率 @ 30 fps

* DSI 0 to HDMI (LT9611)

* 支持 CEC

* 支持分辨率自适应

* 支持热插拔

![](images/image-140.png)


### CEC

HDMI CEC（Consumer Electronics  Control，消费者电子控制）是 HDMI 标准中的一项功能，旨在通过单一的 HDMI 连接线实现多设备之间的互联与统一控制。具体来说，CEC 允许连接的设备通过专用的 CEC 引脚进行通信，从而实现例如通过一个遥控器控制多台设备的功能。

使用下面命令 安装 cec-client 工具。

```shell
sudo apt install cec-utils
```

将 HDMI 线连接到电视后，可使用下面命令查看电视是否支持 CEC：

```shell
echo 'scan' | cec-client -s -d 1
```

若支持 CEC 将会有如下输出:

```plain&#x20;text
opening a connection to the CEC adapter...
requesting CEC bus information ...
CEC bus information
===================
device #0: TV
address:       0.0.0.0
active source: no
vendor:        Sony
osd string:    TV
CEC version:   1.4
power status:  standby
language:      eng


device #1: Recorder 1
address:       1.0.0.0
active source: no
vendor:        Pulse Eight
osd string:    CECTester
CEC version:   1.4
power status:  on
language:      eng


device #4: Playback 1
address:       3.0.0.0
active source: no
vendor:        Sony
osd string:    PlayStation 4
CEC version:   1.3a
power status:  standby
language:      ???
```

若电视支持 CEC 功能，可在 RUBIK Pi 3 中使用下面命令控制电视音量的加减：

```shell
echo 'volup' | cec-client -t p -s
echo 'voldown' | cec-client -t p -s
```

更多 cec-client 使用方法，可使用 `-h` 参数进行查看：

![](images/image-141.png)

### HDMI OUT 触摸屏

RUBIK Pi 3 默认支持 1024\*600P 分辨率的 HDMI OUT 触摸屏，如下图所示：

![](images/img_v3_02h3_18251d67-83e7-498c-b056-5a11783ed13g.jpg)

:::note
>
> 上图中使用的屏幕为 [7 寸 IPS 高清触摸屏幕](https://detail.tmall.com/item.htm?abbucket=12\&id=683025543197\&rn=92499216a472de3107f9541a1b160dc3\&spm=a1z10.5-b-s.w4011-25285306736.152.50aa1c712FMfOS\&skuId=5055110246880)。
:::

### HDMI OUT 调试

RUBIK Pi 3 使用的是 LT9611 这款 DSI-to-HDMI 桥接芯片。

下表列 HDMI 桥接芯片所需的配置。

| 说明                                             | DTSI 节点                                                                                                                                             |
|--------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| 将 DSI-to-HDMI 桥接面板设置为 Primary             | `&sde_dsi { qcom, dsi-default-panel = <&dsi_ext_bridge_1080p>;`                                                                                   |
| 为桥接芯片配置基准电源条目                       | `&sde_dsi { vddio-supply = <&vreg_18c_ip62>; vdda-9p9-supply = <&vreg_11oc_9p88>; vdda-9p9-supply = <&vreg_11oc_9p88>;`                          |
| 为桥接芯片配置面板复位 GPIO                     | `lt9611: lt,lt9611 { reset-options = <&tlmm 21 0>;}`                                                                                               |
| 在外部桥接模式下配置 DSI 主机驱动程序以使用第三方 DSI-to-HDMI 桥接芯片 | `qcom,mdss-dsi-ext-bridge-mode;`                                                                                                                   |

:::note
使用 `sudo -i` 命令切换到 root 用户。
:::

#### 获取 lt9611 日志

要获取 LT9611 日志，请运行以下命令：

```bash
dmesg | grep lt9611
```

查看 log，出现下面的字样代表 HDMI OUT 可以正常运行。

这段日志记录了 LT9611 芯片的初始化和 HDMI 连接过程，从固件版本检测到 CEC 初始化，芯片启动正常。

1. 芯片的固件版本是 0xe2.17.02。这表示芯片初始化时，驱动成功读取了版本信息。

2. LT9611 的 CEC（消费电子控制）功能适配器成功注册。

3. CEC 初始化完成，表明 LT9611 的 CEC 模块已经可以正常工作。

4. 芯片成功读取了 HPD（热插拔检测）状态，并且会有返回值，表示确认 HDMI 设备接入。

5. 芯片检测到视频信号参数：水平分辨率 1920（像素），垂直分辨率 1080（像素），像素时钟频率 148500 kHz（148.5 MHz）。这对应的是 1080p 分辨率（全高清），60Hz 刷新率的典型配置。

```bash
[    5.492765] lt9611 9-0039: LT9611 revision: 0xe2.17.02
[    5.570258] lt9611 9-0039: CEC adapter registered
[    5.582944] lt9611 9-0039: CEC init success

[    8.233028] lt9611 9-0039: success to read hpd status: 13
[    8.233044] lt9611_device_connect_status_notify: send msg[Hdmi Connection] ret[32]
[    8.345015] lt9611 9-0039: hdisplay=1920, vdisplay=1080, clock=148500 
[    8.836662] lt9611 9-0039: video check: hactive_a=1920, hactive_b=1920, vactive=1080, v_total=1125, h_total_sysclk=401, mipi_video_format=170
```

#### 获取 DSI 日志

我们也可以通过输出的 DSI 信息进行调试，DSI 指的是 Display Serial Interface（显示串行接口），通常与移动设备或嵌入式系统的显示驱动（如 MIPI DSI）相关。

这个命令用来查看与显示接口（DSI）相关的内核日志，通常用于调试显示驱动或硬件问题。

```bash
dmesg | grep dsi
```

输出结果示例：

```shell
[    6.831249] i2c 9-0039: Fixed dependency cycle(s) with /soc@0/display-subsystem@ae00000/dsi@ae9400
[   15.070444] lt9611 9-0039: failed to find dsi host
[   17.855362] lt9611 9-0039: failed to find dsi host
[   18.007167] platform ae01000.display-controller: Fixed dependency cycle(s) with /soc@0/display-su0
[   18.014168] platform ae01000.display-controller: Fixed dependency cycle(s) with /soc@0/display-su0
[   18.014317] lt9611 9-0039: Fixed dependency cycle(s) with /soc@0/display-subsystem@ae00000/dsi@ae0
[   18.014460] platform ae94000.dsi: Fixed dependency cycle(s) with /soc@0/geniqup@ac0000/i2c@a840009
[   18.014514] platform ae94000.dsi: Fixed dependency cycle(s) with /soc@0/display-subsystem@ae000000
[   18.372993] lt9611 9-0039: failed to find dsi host
[   18.803189] msm_dpu ae01000.display-controller: bound ae94000.dsi (ops dsi_ops [msm])
```

#### 获取调压器信息

要检查调压器状态和电压，请运行以下命令：

```shell
cat /sys/kernel/debug/regulator/regulator_summary
```

#### 获取接口信息

要检索调试 dump 输出（显示接口编号、VSync 计数、欠载计数和接口模式），请运行以下命令：

```shell
cat /sys/kernel/debug/dri/0/encoder*/status
```

示例输出

```shell
intf:1  wb:-1  vsync:    2580     underrun:       0    frame_done_cnt:0mode: INTF_MODE_VIDEO
intf:-1  wb:2  vsync:       0     underrun:       0    frame_done_cnt:0mode: INTF_MODE_WB_LINE
```

#### 获取常规 DPU 调试信息

常见的 DPU 调试信息说明如下：

要检查 DPU 时钟速率，请运行以下命令：

```shell
cat /sys/kernel/debug/clk/clk_summary | grep disp_cc
```

将 DPU 设置为性能模式

```shell
cd /sys/kernel/debug/dri/0/debug/core_perf/
echo 1 > perf_mode
```

## DisplayPort

RUBIK Pi 3 拥有 1 个 USB Type-C 接口的 DisplayPort，如下图 5。

DP 的参数如下：

* 3840 × 2160 分辨率 @ 60 fps

* 单流传输 (Single stream transport)

* DisplayPort 和 USB 3.0 的并发功能

![](images/image-139.png)

:::note
>
> 在 Ubuntu24.04 V1.0.0 版本中，暂不支持 DP 功能，DP 功能将在后续的版本中支持。
:::

### Wi-Fi

Wi-Fi 是一种使用 IEEE 802.11 协议的无线网络技术。它允许智能手机、可穿戴设备、笔记本电脑、台式机和其他消费电子产品等电子设备在没有物理电缆的情况下连接到互联网。

#### 工作频段

&#x20;AP6256 Wi-Fi 模块支持 2.4 GHz、5 GHz 工作频段。

#### 工作模式

Wi-Fi 软件在以下模式下运行：

| 模式       | 说明                                                                                                                                             |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| STA 模式   | 在 STA 模式下，设备连接到 Wi-Fi 网络中的接入点，并与网络中的其他设备进行通信。此模式是 Wi-Fi 连接中的无线设备的标准模式。                |
| 热点模式   | 热点模式使设备能够使用蜂窝链路 (LTE) 向 Wi-Fi 客户端提供回程 (Internet) 连接。该设备通过其轻量级热点接口建立此连接。在热点模式下，设备可以：与连接到同一热点的其他 Wi-Fi 客户端通信。与热点设备通信。共享设备的 WAN 连接。 |



<Tabs>
    <TabItem value="Wi-Fi STA" label="STA 模式" default>
    在 STA 模式（Station）下，设备可连接到一个已经存在的无线网络，以便访问网络资源或互联网。

    1. 使用命令扫描 Wi-Fi

    ```shell
    nmcli dev wifi list 2>&1 | less
    ```
    ![](images/image-143.png)

    :::note
    按下 `q` 退出
    :::
    2. 使用命令连接 Wi-Fi
    ```shell
    sudo nmcli dev wifi connect <WiFi-SSID> password <WiFi-password>
    ```

    例如，运行命令

    ```shell
    sudo nmcli dev wifi connect rubikpiwifi password 123456789
    ```

    其中，Wi-Fi SSID 为 `rubikpiwifi`，Wi-Fi 密码为 `123456789`。&#x20;

    示例输出

    ```shell
    Device 'wlan0' successfully activated with 'e8b98f24-3f23-4742-8aa3-0d37c5ee6564'.
    ```

    :::note
    如果您在运行命令时看到网络错误消息，请运行以下命令之一来触发 Wi-Fi 扫描并验证目标 AP。&#x20;

    * `nmcli dev wifi list`

    * `iw dev wlan0 scan `       &#x20;
    :::
    3. 要查看连接状态，请运行以下命令：

    ```shell
    nmcli general status
    ```

    示例输出

    ```shell
    STATE  CONNECTIVITY  WIFI-HW  WIFI    WWAN-HW  WWAN
    connected  full     enabled  enabled  enabled  enabled
    ```
    4. 要验证连接状态，请执行以下步骤：
        1. 要查看设备状态，请运行以下命令：

        ```shell
        nmcli dev status
        ```

        示例输出

        ```
        DEVICE  TYPE      STATE        CONNECTION
        wlan0   wifi      connected    RUbikpiWiFi
        eth0    ethernet  unavailable  --
        eth1    ethernet  unavailable  --
        can0    can       unmanaged    --
        lo      loopback  unmanaged    --
        ```
        2. 要查看附加连接信息，请运行以下命令：

        ```
        nmcli device show wlan0
        ```

        示例输出

        ```
        GENERAL.DEVICE:                         wlan0
        GENERAL.TYPE:                           wifi
        GENERAL.HWADDR:                         00:03:7F:12:F7:F7
        GENERAL.MTU:                            1500
        GENERAL.STATE:                          100 (connected)
        GENERAL.CONNECTION:                     QualcommWiFi
        GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/5
        IP4.ADDRESS[1]:                         192.168.117.130/24
        IP4.ADDRESS[2]:                         192.168.117.131/24
        IP4.GATEWAY:                            192.168.117.126
        ```
        3. 通过在 UART 控制台中运行 ifconfig wlan0 命令来验证是否在 wlan0 接口上分配了 IP 地址

        ```
        ifconfig wlan0
        ```
        :::note
        >
        > 可输入命令 `sudo apt install net-tools` 安装 ifconfig 命令。
        :::

        4. 通过 ping 以下公共 DNS IP：验证 AP 或路由器是否已连接至 Internet

        ```
        ping 8.8.8.8
        ```
    :::note
     * 如果您已连接至一个网络，但想要使用另一连接，则可以通过指定 SSID `nmcli con down  ssid/uuid` 将连接切换为关闭来断开连接。或者，如果您有多个具有相同 SSID 的连接，请使用 UUID。

    * 要连接到另一个已保存的连接，只需运行以下命令来传递 `nmcli` 命令行工具中的 up 选项即可。`nmcli con up ssid/uuid`
    :::

    :::note
    要退出标准输入 shell，请按 CTRL+C。
    :::

    有关 `nmcli` 的更多信息，请参阅 https://www.linux.org/docs/man1/nmcli.html 和 https://networkmanager.dev/docs/api/latest/nmcli.html
    </TabItem>

    <TabItem value="Wi-Fi AP" label="AP 模式" default>

    AP 模式（Access Point）即无线接入热点模式，是一个无线网络的创建者，是网络的中心节点，一般家庭或办公室使用的无线网络路由器就是一个 AP，下面是 AP 的创建步骤：

    * 开启 AP
        * 创建或修改 */opt/hostapd.conf&#x20;*&#x20;文件：

          ```plain&#x20;text
          ctrl_interface=/var/run/hostapd
          driver=nl80211
          ieee80211n=1
          interface=wlan1
          hw_mode=a
          channel=36
          beacon_int=100
          dtim_period=1
          ssid=RUBIKPi
          auth_algs=1
          ap_isolate=0
          ignore_broadcast_ssid=0
          wpa=2
          wpa_key_mgmt=WPA-PSK
          rsn_pairwise=CCMP
          wpa_passphrase=123456789
          ```

        * 执行下面命令开启 AP：

          ```shell
          hostapd -B /opt/hostapd.conf # 设置软件AP
          # 启动动态主机配置协议（DHCP）服务器
          brctl addbr br0
          brctl addif br0 wlan1
          ifconfig br0 192.168.225.1 netmask 255.255.255.0 up
          killall dnsmasq
          dnsmasq --conf-file=/etc/dnsmasq.conf --dhcp-leasefile=/var/run/dnsmasq.leases --addn-hosts=/data/hosts --pid-file=/var/run/dnsmasq.pid -i br0 -I lo -z --dhcp-range=br0,192.168.225.20,192.168.225.60,255.255.255.0,43200 --dhcp-hostsfile=/data/dhcp_hosts --dhcp-option-force=6,192.168.225.1 --dhcp-script=/bin/dnsmasq_script.sh
          ```

  * 若要与 hostapd\_cli 建立连接，可使用下面命令

    ```shell
    hostapd_cli -i wlan1 -p /var/run/hostapd
    ```

  在 `hostapd_cli` 控制台中监视 Wi-Fi STA 连接通知，例如 `AP-STA-CONNECTED`、 `EAPOL-4WAY-HS-COMPLETED`

  示例输出
  ```shell
  root@rubikpi:~# hostapd_cli -i wlanl -p /var/run/hostapd
  hostapd_cli v2.11-devel
  Copyright (c) 2004-2022, Jouni Malinen <j@wl.fi> and contributors
  This software may be distributed under the terms of the BSD License. 
  See README for more details.

  Interactive mode
  > <3>AP-STA-CONNECTED aa: a4: fd: 8b: ec: 90
  <3>EAPOL-4WAY-HS-COMPLETED aa: a4: fd: 8b:ec:90

  > list_sta
  aa: a4: fd: 8b:ec:90
  ```
 若开启 AP 5G 模式前，未使用 STA 连接过 5G Wi-Fi，则需使用如下命令，查看环境中 5G channel 的配置
  ```shll
  iw dev wlan0 scan
  ```
 在命令执行结果中通过，primary channel 字段确定当前已被激活 channel，如下所示，channel 字段为 36，将36 写入 */opt/hostapd.conf* 文件中的 channel 字段即可


 ```
 HT operation:
                 * primary channel: 36
                 * secondary channel offset: above
                 * STA channel width: any
                 * RIFS: 0
                 * HT protection: nonmember
                 * non-GF present: 0
                 * OBSS non-GF present: 0
                 * dual beacon: 0
                 * dual CTS protection: 0
                 * STBC beacon: 0
                 * L-SIG TXOP Prot: 0
                 * PCO active: 0
                 * PCO phase: 0
```
    * 验证 AP

        要验证连接状态，请从其他设备连接到 AP。&#x20;

        例如，通过执行以下步骤从移动设备连接到 AP：

        1. 在移动设备上，转到 Wi-Fi settings。

        2. 等待 Wi-Fi STA 检测到 AP。

        3. 选择 AP 并输入在 RUBIK Pi 3 设备上为 AP 配置的相应 `wpa_passphrase`，然后进行连接。&#x20;
        ```shell
        > status
        state=ENABLED
        phy=phyR freq=2412
        num_sta_non_erp=0
        num_sta_no_short_slot_time=0
        num_sta_no_short_preamble=0
        olbc=0
        num_sta_ht_no_gf=0 num_sta_no_ht=0
        num_sta_ht_20_mhz=0
        num_sta_ht40_intolerant=0
        olbc_ht=0
        ht_op_mode=0x0
        hw_mode=g
        country_code=US
        country3=0x20
        cac_time_seconds=0
        cac_time_left_seconds=N/A
        channel=1
        edmg_enable=0 edmg_channel=0
        secondary_channel=0
        ieee80211n=1
        ieee80211ac=0
        ieee80211ax=0
        ieee80211be=0
        beacon_int=100
        dtim_period=2
        ht_caps_info=000c
        ht_mcs_bitmask=ffff0000000000000000
        supported_rates-02 04 0b 16 Oc 12 18 24 30 48 60 6c
        max_txpower=30
        bss[0]=wlan1
        bssid[0]=00:03:7f:95:8e:8e
        ssid [0]=QSoftAP
        num_sta[0]=1
        > |
        ```
    要验证连接，在 RUBIK Pi 3 设备的 `ssh shell` 中 ping 移动设备的 IP 地址。

    以下输出表示 Wi-Fi 连接已成功建立，数据传输已开始：&#x20;

    ```shell
    sh-5.1# ping 192.168.1.42
    PING 192.168.1.42 (192.168.1.42): 56 data bytes
    64 bytes from 192.168.1.42: seq=0 ttl=64 time-11.175 ms
    64 bytes from 192.168.1.42: seq=1 ttl=64 time=14.528 ms
    64 bytes from 192.168.1.42: seq=2 ttl=64 time=29.735 ms
    64 bytes from 192.168.1.42: seq=3 ttl=64 time=223.822 ms
    64 bytes from 192.168.1.42: seq-4 ttl=64 time-23.675 ms
    ^C
    192.168.1.42 ping statistics ---
    7 packets transmitted, 5 packets received, 28% packet loss
    round-trip min/avg/max = 11.175/60.587/223.822 ms
    sh-5.1#
    ```

    也可以在连接设备的 Settings 中验证 Wi-Fi 连接状态。例如，要获取连接到 RUBIK Pi 3 AP 的移动设备的 IP 地址，执行以下步骤：
        1. 导航至 Settings > Wi-Fi。

        2. 验证 AP 的 SSID。

    * 关闭 AP：

    要停止 AP，在 SSH 中执行以下操作：

    1. 通过执行以下步骤停止 hostapd：

       1. 要停止 hostapd 过程，可运行以下命令：

          ```plain&#x20;text
          killall hostapd
          ```

       2. 要禁用接口，可运行以下命令：

          ```plain&#x20;text
          ifconfig wlan1 down
          ```

    2. 请运行以下命令，以便删除 `ctrl_interface`：

       ```plain&#x20;text
       rm -rf /var/run/hostapd/wlan1
       ```

    Wi-Fi 热点成功停止。

    </TabItem>
</Tabs>


<a id="blue"></a>
### 蓝牙

蓝牙® 无线技术是一种短距离通信系统，可实现设备之间的无线数据交换。蓝牙技术的主要优势如下：

* 替代便携式和固定式电子设备的线缆

* 提供稳健、节能且经济高效的解决方案

* 促进解决方案及其应用的灵活性。

#### 打开蓝牙测试应用程序

* 通过运行以下命令打开蓝牙测试应用程序，所有蓝牙配置命令都在此应用程序中执行：

```shell
bluetoothctl
```
示例输出
![](images/20250714-213000.png)

#### 启用蓝牙
* 要启用设备蓝牙，可运行以下命令：
```shell
power on
```
示例输出
![](images/20250714-213200.png)


<a id="blue_scan"></a>
#### 运行蓝牙查询扫描
* 要启动对附近设备的查询，运行以下命令：
```shell
scan on
```
示例输出
![](images/20250714-213400.png)

#### 停止蓝牙扫描
* 请运行以下命令，以便停止正在进行的查询：
```shell
scan off
```
示例输出
![](images/20250714-213500.png)

#### 与远程蓝牙设备配对

在配对远程设备之前，[运行蓝牙查询](#blue_scan) 扫描以确保远程设备可用。
* 要与远程蓝牙设备配对，请运行以下命令：
```shell
pair <bt_address>
```
要接受主动/被动配对，输入 `yes`。要拒绝主动/被动配对，输入 `no`。
参数 `<bt_address>` 是远程设备的蓝牙地址。
示例
  要使用 `<bt_address> 00:25:02:02:7B:A4` 与远程设备配对，请运行以下命令：
  ```shell
  pair 00:25:02:02:7B:A4
  ```
示例输出
```
[bluetooth] pair 00:25:02:02:7B:A4
Attempting to pair with 00:25:02:02:7B:A4
[bluetooth]# hci0 device_flags_changed: 00:25:02:02:7B:A4 (BR/EDR)
[bluetooth]#      supp: 0x00000001  curr: 0x00000000
[bluetooth]# hci0 00:25:02:02:7B:A4 type BR/EDR connected eir_len 20
[CHG] Device 00:25:02:02:7B:A4 Connected: yes
[OPPO Enco W31]# hci0 new_link_key 00:25:02:02:7B:A4 type 0x04 pin_len 0 store_hint 1
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 Bonded: yes
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 UUIDs: 00000001-0000-1000-8000-00805f9b34fb
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 UUIDs: 00001107-d102-11e1-9b23-00025b00a5a5
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000110b-0000-1000-8000-00805f9b34fb
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000110e-0000-1000-8000-00805f9b34fb
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000110f-0000-1000-8000-00805f9b34fb
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000111e-0000-1000-8000-00805f9b34fb
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 UUIDs: 00001203-0000-1000-8000-00805f9b34fb
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 ServicesResolved: yes
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 Paired: yes
[OPPO Enco W31]# Pairing successful
[OPPO Enco W31]# hci0 00:25:02:02:7B:A4 type BR/EDR disconnected with reason 2
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 ServicesResolved: no
[CHG] Device 00:25:02:02:7B:A4 Connected: no
[bluetooth]# hci0 00:25:02:02:7B:A4 type BR/EDR connected eir_len 20
[CHG] Device 00:25:02:02:7B:A4 Connected: yes
[OPPO Enco W31]# Authorize service
[agent] Authorize service 0000110d-0000-1000-8000-00805f9b34fb (yes/no): yes
[OPPO Enco W31]# Authorize service
[OPPO Enco W31]#   1;39m[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 00000001-0000-1000-8000-00805f9b34fb
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 00001107-d102-11e1-9b23-00025b00a5a5
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000110b-0000-1000-8000-00805f9b34fb
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000110d-0000-1000-8000-00805f9b34fb
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000110e-0000-1000-8000-00805f9b34fb
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000110f-0000-1000-8000-00805f9b34fb
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 0000111e-0000-1000-8000-00805f9b34fb
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [CHG] Device 00:25:02:02:7B:A4 UUIDs: 00001203-0000-1000-8000-00805f9b34fb
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [NEW] Endpoint /org/bluez/hci0/dev_00_25_02_02_7B_A4/sep1 
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): [NEW] Endpoint /org/bluez/hci0/dev_00_25_02_02_7B_A4/sep2       
[agent] Authorize service 0000111f-0000-1000-8000-00805f9b34fb (yes/no): yes
[OPPO Enco W31]#
```

#### 获取绑定/配对设备列表

* 要获取已验证的配对设备列表，运行以下命令：

```shell
devices
```

示例输出
![](images/20250714-214100.png)

#### 连接远程设备
* 要连接远程设备，请从运行以下命令：
```shell
connect <bt_address>
```
参数 `<bt_address>` 是远程设备的蓝牙地址。

示例
  要使用 `<bt_address> 00:25:02:02:7B:A4` 连接到已配对的远程设备，请运行以下命令：

```shell
connect 00:25:02:02:7B:A4
```
示例输出
```
[bluetooth]# connect 00:25:02:02:7B:A4
Attempting to connect to 00:25:02:02:7B:A4
[bluetooth]# [CHG] Device 66:90:8B:13:9F:50 RSSI: 0xffffffb2 (-78)
[bluetooth]# [CHG] Device 00:25:02:02:7B:A4 AddressType: public
[bluetooth]# [CHG] Device 3F:5B:7D:73:30:9E ServiceData.0000fe95-0000-1000-8000-00805f9b34fb:
[bluetooth]#   70 20 5b 04 5e 9e 30 73 7d 5b 3f 09 04 10 02 ff  p [.^.0s}[?.....
[bluetooth]#   00                                               .               
[bluetooth]# [CHG] Device 47:6E:17:4C:2A:3C RSSI: 0xffffffb8 (-72)
[bluetooth]# [NEW] Device 54:38:90:28:DE:0A 54-38-90-28-DE-0A
[bluetooth]# [DEL] Device 28:6B:35:B5:C3:D0 CN8900578W2
[bluetooth]# hci0 00:25:02:02:7B:A4 type BR/EDR connected eir_len 15
[CHG] Device 00:25:02:02:7B:A4 Connected: yes
[OPPO Enco W31]# [NEW] Endpoint /org/bluez/hci0/dev_00_25_02_02_7B_A4/sep1 
[OPPO Enco W31]# [NEW] Endpoint /org/bluez/hci0/dev_00_25_02_02_7B_A4/sep2 
[OPPO Enco W31]# [NEW] Transport /org/bluez/hci0/dev_00_25_02_02_7B_A4/sep1/fd4 
[OPPO Enco W31]# Connection successful
[OPPO Enco W31]# [CHG] Device 00:25:02:02:7B:A4 ServicesResolved: yes
[OPPO Enco W31]# [CHG] Transport /org/bluez/hci0/dev_00_25_02_02_7B_A4/sep1/fd4 State: active
```

#### 取消设备配对
* 要取消配对设备，请运行以下命令：
```Shell
remove <bt_address>
```
示例输出

![](images/20250714-214400.png)

#### 启用设备发现

* 要在 DUT 中启用发现模式，请运行以下命令：
```shell
discoverable on
```
示例输出
![](images/20250714-214800.png)

#### 关闭蓝牙

* 请运行以下命令，以便在设备上禁用蓝牙：
```shell
power off
```
示例输出
![](images/20250714-214900.png)


## 音频

RUBIK Pi 3 目前支持的音接口为：

* 3.5mm 耳机，下图4。

* HDMI OUT， 下图9。

* 蓝牙

![](images/image-133.png)

### 使能音频功能
    1. 将 Qualcomm 和魔方派公共个人软件包档案 (PPA) 添加到您的魔方派 3 Ubuntu 软件源。
    ```shell
    sudo add-apt-repository ppa:ubuntu-qcom-iot/qcom-noble-ppa
    sudo sed -i '$a deb http://apt.rubikpi.ai ppa main' /etc/apt/sources.list
    sudo apt update
    ```
    2. 使用如下命令安装音频相关的软件包, 安装完成后, 重启设备，使能音频。
    ```shell
    sudo apt install libsndfile1 libltdl7 libspeexdsp1 qcom-fastrpc1 \
    rubikpi3-tinyalsa rubikpi3-tinycompress rubikpi3-qcom-agm rubikpi3-qcom-args rubikpi3-qcom-pal \
    rubikpi3-qcom-audio-ftm rubikpi3-qcom-audioroute rubikpi3-qcom-acdbdata rubikpi3-qcom-audio-node \
    rubikpi3-qcom-kvh2xml rubikpi3-qcom-pa-bt-audio rubikpi3-qcom-sva-capi-uv-wrapper rubikpi3-qcom-sva-cnn \
    rubikpi3-qcom-sva-listen-sound-model rubikpi3-qcom-sva-eai rubikpi3-qcom-pa-pal-voiceui rubikpi3-qcom-pa-pal-acd \
    rubikpi3-qcom-audio-plugin-headers rubikpi3-qcom-dac-mer-testapp rubikpi3-qcom-dac-plugin rubikpi3-qcom-mercury-plugin \
    rubikpi3-pulseaudio rubikpi3-diag rubikpi3-dsp rubikpi3-libdmabufheap rubikpi3-qcom-vui-interface rubikpi3-qcom-vui-interface-header \
    rubikpi3-time-genoff rubikpi3-pa-pal-plugins

    sudo usermod -aG audio,pulse,plugdev,video,render ubuntu  # ubuntu 按实际情况更换，用户名
    ```

* 在魔方派 3 中输入下面命令，查看声卡挂载情况：
```shell
cat /proc/asound/cards
```
![](images/20250714-215200.png)

### 设置输出源

在魔方派 3 中输入下面命令，改变pulseaudio相关命令的音频输出源头：

* 设置输出接口为 3.5mm Headset
```shell
pactl set-default-sink low-latency0
pactl set-sink-port low-latency0 headset
```
* 设置输出接口为 HDMI OUT
```shell
pactl set-default-sink low-latency0
pactl set-sink-port low-latency0 hdmi-out
```

* 设置输出接口为 Bluetooth，请参考 [蓝牙](#blue) 章节，确保蓝牙已连接
    * 执行以下命令，确认当前的蓝牙设备支持的音频信息，不同的蓝牙设备之间存在差异
    ```shell
    pactl list cards
    ```
    示例输出
    ![](images/20250714-215600.png)

    * 执行以下命令，切换蓝牙音频输出Profile
    ```shell
    pactl set-card-profile <Card-Name> <Profile>
    ```
    示例
    ```shell
    # 切换到通话模式 (HFP/HSP)
    pactl set-card-profile bluez_card.00_25_02_02_7B_A4 handsfree_head_unit
    ```
    * 执行以下命令，查看蓝牙相关source信息
    ```shell
    pactl list sources
    ```
    示例输出
    ![](images/20250714-215900.png)

    * 执行以下命令，切换蓝牙音频输入接口
    ```shell
    pactl set-default-source <Source-Name>
    ```
    示例
    ```shell
    pactl set-default-source bluez_source.00_25_02_02_7B_A4.handsfree_head_unit
    ```

### 播放
:::wiring
1. 执行以下命令创建 */opt* 目录，并确保 */opt* 路径存在可读写权限
2. 运行命令前，务必将 MP3 测试文件 (`<FileName>.mp3`) 推送到 */opt* 目录下
:::

```shell
mkdir /opt
sudo chmod 777 -R /opt
```
* 在魔方派 3 中输入下面命令测试 .mp3音频播放。
```shell
paplay /opt/<FileName>.mp3
```

### 录制
* 在魔方派 3 中输入下面命令测试 .mp3音频录制。
```shell
parecord /opt/<FileName>.mp3
```

### 调节音量大小
* 调整播放音量大小
    * 执行以下命令，查看输出设备音量
    ```shell
    pactl list sinks | grep -e "Name" -e "Volume" -e "Active Port"
    ```
    示例输出
    ![](images/20250714-220400.png)
    * 执行以下命令，调整当前输出设备音量大小
    ```shell
    pactl set-sink-volume <Sink-Name> <Volume>
    ```
    示例
    ```shell
    pactl set-sink-volume low-latency0 70%
    ```

* 调整录音音量大小
    * 执行以下命令，查看输出设备音量
    ```shell
    pactl list sources | grep -e "Name" -e "Volume" -e "Active Port"
    ```
    示例输出
    ![](images/20250714-220600.png)
    * 执行以下命令，调整当前输出设备音量大小
    ```shell
    pactl set-source-volume <Source-Name> <Volume>
    ```
    示例
    ```shell
    pactl set-source-volume regular0 70%
    ```

### 抓取日志

* 用户空间日志

  要抓取用户空间日志，请执行以下操作：

  ```shell

  cat /var/log/user.log
  ```

* 内核音频驱动程序日志

  要抓取内核日志，请执行以下操作：

  * &#x20;内核日志

    ```shell
    dmesg
    ```

  * 禁用特定文件中的内核日志：

    ```shell
    echo –n “file <filename> -p” > /sys/kernel/debug/dynamic_debug/control

    ```

  * 动态内核日志

    默认情况下，动态日志处于禁用状态。要将其启用，请添加 `CONFIG_DYNAMIC_DEBUG` 内核配置，重新编译并重新刷写设备。

    要启用音频动态内核日志，请执行以下操作：

    ```shell
    ssh root@ip-addr
    mount -o rw,remount /
    mount -t debugfs none /sys/kernel/debug
    echo –n “file <filename> +p” > /sys/kernel/debug/dynamic_debug/control
    ```

### 分析抓取的日志

查看用户空间日志和内核音频驱动程序日志，了解播放和录制用例。

* 播放

  以下日志片段描述了为播放用例收集的信息。

  ```shell
  //Open Low latency Playback stream. Details of each stream type can be found at sources/audio/opensource/arpal-lx/inc/PalDefs.h
  2022-04-28T18:02:08.748280+00:00 pulseaudio: pal_stream_open: 224: Enter, stream type:1

  //Verify the backend device, sample rate, bitwidth, channels etc
  2022-04-28T18:02:08.748627+00:00 pulseaudio: setDeviceMediaConfig: 1056: CODEC_DMA-LPAIF_WSA-RX-0 rate ch fmt data_fmt 48000 2 2 1

  //Start playback stream
  2022-04-28T18:02:08.751947+00:00 pulseaudio: pal_stream_start: 338: Enter. Stream handle 0xffff94001040K

  //Map the metadata with kvh2xml.h file for playback usecase details.
  2022-04-28T18:02:08.853157+00:00 pulseaudio: metadata_print: 82 key:0xa1000000, value:0xa100000e//PCM_LL_PLAYBACK
  2022-04-28T18:02:08.853395+00:00 pulseaudio: metadata_print: 82 key:0xab000000, value:0x1
  2022-04-28T18:02:08.853660+00:00 pulseaudio: metadata_print: 82 key:0xa2000000, value:0xa2000001//Speaker
  2022-04-28T18:02:08.853881+00:00 pulseaudio: metadata_print: 82 key:0xac000000, value:0xac000002//DEVICEPP_RX_AUDIO_MBDRC

  //Verify the graph opened for playback usecase
  2022-04-28T18:02:08.856934+00:00 pulseaudio: print_graph_alias: 2334 GKV Alias 142 | StreamRX_PCM_LL_Playback_DeviceRX_Speaker_Instance_Instance_1_DevicePP_Rx_Audio_MBDRC
  //graph_open called
  2022-04-28T18:02:08.859509+00:00 pulseaudio: graph_open: 709 graph_handle 0x47534c

  //Configure hardware endpoint module
  2022-04-28T18:02:08.864386+00:00 pulseaudio: configure_hw_ep_media_config: 636 entry mod tag c0000004 miid 43b1 mid 7001023
  2022-04-28T18:02:08.864495+00:00 pulseaudio: configure_hw_ep_media_config: 664 rate 48000 bw 16 ch 2, data_fmt 1
  2022-04-28T18:02:08.864603+00:00 pulseaudio: configure_hw_ep_media_config: 676 exit, ret 0

  //graph_start entry
  2022-04-28T18:02:08.867234+00:00 pulseaudio: graph_start: 899 entry graph_handle 0x47534c
  //Stream started
  2022-04-28T18:02:08.867864+00:00 pulseaudio: pal_stream_start: 387: Exit. status 0

  //graph_stop entry
  2022-04-28T18:02:25.037338+00:00 pulseaudio: graph_stop: 928 entry graph_handle 0x47534c
  //Stop the PAL stream once playback completes
  2022-04-28T18:02:25.039923+00:00 pulseaudio: pal_stream_stop: 441: Exit. status 0

  //graph_close entry
  2022-04-28T18:02:25.050944+00:00 pulseaudio: graph_close: 762 entry handle 0x47534c
  //Close the PAL stream
  2022-04-28T18:02:25.054510+00:00 pulseaudio: pal_stream_close: 322: Exit. status 0

  ```

* 录制

  以下日志片段描述了为录制用例收集的信息。

  ```shell
  //Open Recording stream for PAL_STREAM_RAW. Details of stream type can be found at sources/audio/opensource/arpal-lx/inc/PalDefs.h
  Apr 29 09:23:11 pulseaudio[862]: pal_stream_open: 224: Enter, stream type:9

  //Verify the backend device, sample rate, bitwidth, channels etc
  Apr 29 09:23:11 pulseaudio[862]: setDeviceMediaConfig: 1056: CODEC_DMA-LPAIF_VA-TX-0 rate ch fmt data_fmt 48000 1 2 1

  //Start recording stream
  Apr 29 09:23:11 pulseaudio[862]: pal_stream_start: 338: Enter. Stream handle 0xffff6c001040K

  //graph_open entry
  Apr 29 09:23:11 pulseaudio[862]: graph_open: 709 graph_handle 0x47534c

  //Metadata details to identify the usecase
  Apr 29 09:23:11 pulseaudio[862]: metadata_print: 82 key:0xb1000000, value:0xb1000009//RAW_RECORD
  Apr 29 09:23:11 pulseaudio[862]: metadata_print: 82 key:0xa3000000, value:0xa3000004//HANDSETMIC

  //Verify the graph opened for recording usecase
  Apr 29 09:23:11 pulseaudio[862]: print_graph_alias: 2334 GKV Alias 29 | DeviceTX_Handset_Mic_StreamTX_RAW_Record

  //Configure hardware endpoint module
  Apr 29 09:23:11 pulseaudio[862]: configure_hw_ep_media_config: 636 entry mod tag c0000005 miid 43af mid 7001024
  Apr 29 09:23:11 pulseaudio[862]: configure_hw_ep_media_config: 664 rate 48000 bw 16 ch 1, data_fmt 1
  Apr 29 09:23:11 pulseaudio[862]: configure_hw_ep_media_config: 676 exit, ret 0

  //graph_start entry
  Apr 29 09:23:11 pulseaudio[862]: graph_start: 899 entry graph_handle 0x47534c
  //Stream recording started
  Apr 29 09:23:11 pulseaudio[862]: pal_stream_start: 387: Exit. status 0


  //graph_stop entry
  Apr 29 09:23:26 pulseaudio[862]: graph_stop: 928 entry graph_handle 0x47534c
  //Stop the PAL stream once user stops recording
  Apr 29 09:23:26 pulseaudio[862]: D: [regular2] pal-source.c: pal_stream_stop returned 0

  //Close the PAL stream
  Apr 29 09:23:26 pulseaudio[862]: pal_stream_close: 284: Enter. Stream handle :0xffff6c001040K
  //graph_close entry
  Apr 29 09:23:26 pulseaudio[862]: graph_close: 762 entry handle 0x47534c
  //Close the PAL stream
  Apr 29 09:23:26 pulseaudio[862]: pal_stream_close: 322: Exit. status 0

  ```



## 风扇

RUBIK Pi 3 兼容 [树莓派 5 的散热套件](https://www.raspberrypi.com/products/active-cooler/):

:::warning
>
> 使用 RUBIK Pi 3 在运行一些高负载或高性能的场景下，需要使用散热措施来保证设备性能稳定，否则会因为 CPU 温度过高而带来降频等性能影响。
:::

### 风扇安装

1. **将散热器背面所有导热硅脂移除**，将下图标记的两块硅脂按 RUBIK Pi 3 的 SoC 及 uMCP 的形状裁下。

![](images/image-132.png)

两块的表面尺寸约为14\*12mm和13\*11.5mm。

![](images/image-152.png)

2. 将裁剪好的两块导热硅脂贴在 RUBIK Pi 3 上对应位置。

![](images/20250220-095205.jpg)


3. 安装散热器，连接风扇排线。

  ![](images/20250314-155449.jpg)

  :::warning
  >
  > 建议将风扇安装到 RUBIK Pi 3 上后不要将其取下。拆卸会导致风扇的推针和散热垫退化，并可能导致产品损坏。如果推针损坏或变形，或无法牢固夹住，请停止使用风扇。
  :::

### 风扇控制方法

RUBIK Pi 3 风扇会根据当前的 CPU 温度自动调整转速，同时也可在 RUBIK Pi 3 中使用下面命令进行手动控制转速，0 和 255 分别表示风扇的最高和最低速度。

```shell
echo 100 >  /sys/devices/platform/pwm-fan/hwmon/hwmon*/pwm1
echo 255 >  /sys/devices/platform/pwm-fan/hwmon/hwmon*/pwm1
echo 0 >  /sys/devices/platform/pwm-fan/hwmon/hwmon*/pwm1
```

:::note
在将风扇转速设置为一个固定值前时，需要使用 `systemctl stop rubikpi-thermal` 命令将风扇热管理服务关掉。
:::

## LED

RUBIK Pi 3 上有一个由 PMIC 驱动的 RGB 的三色灯，默认情况下其中的绿色灯被设置为了心跳灯用来反馈系统的运行情况和 CPU 负载情况（CPU 负载大时，心跳灯闪烁频率也跟着变大）。

如下是 LED 灯不同状态时，所指示的状态：

* 蓝灯长亮：fastboot 模式

* 绿色心跳：正常工作

* 红色心跳：低功耗电源插入（小于 12V  2.25A）

* 快速心跳： CPU 高负荷工作

* 停止心跳：

  * 系统死机

  * 进入睡眠

  * 正在开机中

可使用如下命令，操作 LED 灯：

* 关闭心跳灯

  ```shell
  echo none > /sys/class/leds/green/trigger
  ```

* 开启心跳灯

  ```shell
  echo heartbeat > /sys/class/leds/green/trigger
  ```

* 设置绿灯的亮度（亮度 0 - 511，如下为设置亮度为100）

  ```shell
  echo 100 >  /sys/class/leds/green/brightness
  ```

* 设置红灯的亮度（亮度 0 - 511，如下为设置亮度为100）

  ```shell
  echo 100 >  /sys/class/leds/red/brightness
  ```

* 设置蓝灯的亮度（亮度 0 - 511，如下为设置亮度为100）

  ```shell
  echo 100 >  /sys/class/leds/blue/brightness
  ```

## 以太网

以太网技术旨在使用有线技术以不同的链路速度传输数据。它使用线缆在网络模型（例如局域网 (LAN) 和广域网 (WAN)）中传输数据，实现可靠、安全和更出色的网络连接。

以太网连接集成到 IoT 设备和传感器，使它们能够将数据传输到网络。它根据 IEEE 802.3 标准定义，可为这些设备提供用于与网关通信的标准化接口。

以太网接口为下图 8， RUBIK Pi 3 支持千兆以太网：

![](images/image-150.png)

接入网线，如下图所示：

![](images/20250314-155445.jpg)

可在 RUBIK Pi 3 中使用 `ifconfig` 命令查看网络连接情况，如下图所示，已经成功分配 IP，说明网络连接成功：

![](images/image-151.png)
:::note
>
> 可输入命令 `sudo apt install net-tools` 安装 ifconfig 命令。
:::

### 调试以太网

可以使用以下日志类型来记录和调试与以太网有关的问题。

* `dmesg`：调试与内核驱动程序相关的问题

* `tcpdump`： 验证数据包传输

要调试在以太网调通期间可能出现的问题，请执行以下操作：

1. 要收集 `dmesg` 日志并调试与内核驱动程序有关的问题，请运行以下命令：

   ```shell
   dmesg > /var/log/dmesg_logs.txt
   ```

2. 要收集 `tcpdump` 日志并验证数据包传输，请运行以下命令。

   ```shell
   tcpdump -i any -s 0 -w /var/log/tcpdump.pcap
   ```

3. 收集来自 `ethtool`、`ifconfig`、`netstat` 和 IP 路由表的输出以进行调试。

## RTC 电池接口

RTC (Real\_Time Clock) 电池接口为下图 1。

![](images/image-147.png)

接入 RTC 电池， 如下图所示，并将时间写入 RUBIK Pi 3 的系统硬件时钟，可在 RUBIK Pi 3 完全断电后，仍对 RUBIK Pi 3 的系统时间进行保存。

![](images/20250314-155435.jpg)

在 RUBIK Pi 3 中将系统时间写入系统硬件时钟方法如下：

```shell
sudo timedatectl set-time "2025-06-03 21:12:11"
sudo timedatectl set-local-rtc true
```

## M.2 Key M 接口

RUBIK Pi 3 提供一个标准 M.2 插槽，用于连接 NVMe 存储，可安装 2280 规格（22\*80mm）M.2 SSD 硬盘。M.2 插槽最大支持 PCIe Gen 3 x 2。M.2 接口最大对外输出能力为 3.3V 2A，可单独控制开关。

M.2 Key M 接口使用了 QCS6490 的 PCIe1 总线，设备路径为：*/sys/bus/pci/devices/0001:00:00.0*

M.2 Key M 接口为下图 18：

![](images/image-148.png)

M.2 Key M 接口可以接入规格为2280的固态硬盘，如下图所示：

![](images/img_v3_02h3_2bbba98e-82ca-47ed-9b20-cf96deb8e13g.jpg)
![](images/img_v3_02h3_f64471dd-11fb-46bd-ae8a-72fdf86cc65g.jpg)


### PCIe 总线功能验证
在接入 2280 规格的固态硬盘后，生成的设备节点为 `/dev/nvme*`。

您可以通过类似如下的命令挂载 U 盘，通过访问 */opt* 目录下的内容验证 PCIe 总线接口。
```shell
sudo mount /dev/nvme0n1p1 /opt/
```

### PCIe 功耗优化

PCIe 定义了两种功耗管理方法。

* 功耗管理软件，用于确定每个设备的功耗管理功能并分别对各个设备进行管理

* 不需要软件干预的系统，例如主动状态功耗管理 (ASPM)

当链路上未传输任何数据包时，设备会将链路置于节能状态。

#### PCIe L0 链路状态

PCIe 功耗管理定义下了 L0 链路状态：

* L0：工作状态

* L0s：具有低恢复延迟的 ASPM 状态（节能待机状态）

#### PCIe 设备状态

PCIe 功耗管理定义了以下设备状态：

* D0（必选）: 设备处于完全 ON 状态，此时存在两个子状态

  * D0(uninitialized)：当设备退出复位状态后等待枚举和配置时，该功能处于 D0(uninitialized) 状态

  * D0(active)

    * 当完成枚举和配置过程后，该功能处于 D0(active) 状态

    * 当系统软件启用一个或多个（任意组合）功能参数（如内存空间启用、I/O 空间启用、总线主启用（BME）位）时，该功能进入 D0(active) 状态

* D1（可选）：轻度休眠状态

  * 该功能只能发出 PME 消息，无法发出其他 TLP

  * 该功能只能充当配置事务的目标，无法充当其他事务的目标

  * 该功能通过发出设定 PM 控制和状态寄存器的软件命令来进入 D1 状态

* D2（可选）：深度休眠状态

  * 该功能只能发出 PME 消息，无法发出其他 TLP

  * 该功能只能充当配置事务的目标，无法充当其他事务的目标

  * 该功能通过发出设定 PM 控制和状态寄存器的软件命令来进入 D2 状态

* D3（必选）：设备处于最低功耗状态，此时该功能必须支持两种 D3 状态

* D3(hot)

  * 该功能只能发出 PME 消息，无法发出其他 TLP

  * 该功能只能充当配置事务的目标，无法充当其他事务的目标

  * 该功能通过设定功耗状态位域发出软件命令来进入 D3(hot) 状态

* D3(cold)：设备进入 D3(cold) 状态并断电；当恢复供电时，设备进入 D0(uninitialized) 状态

### PCIe 调试

M.2 Key M 接口使用了 QCS6490 的 PCIe1 总线，设备路径为：*/sys/bus/pci/devices/0001:00:00.0*

`lspci` 和 `setpci` 命令为 Linux 发行版的本机命令。这两条命令提供多种级别的输出，并且还可用于在某个时间点查看 PCI 总线上训练的不同组件的功能和状态。这些功能大多反映的是 PCIe 基本规范所需的配置空间寄存器。更多详细信息，可访问 https://pcisig.com/specifications
如需查看使用说明，可运行以下命令。

```shell
lspci --help
```

以下功能有助于解决 PCIe 问题。

* 显示设备信息

  ```shell
  lspci
  ```

  示例输出

  ```shell
  0000:00:00.0 PCI bridge: Qualcomm Device 010b
  0000:01:00.0 USB controller: Renesas Technology Corp. uPD720201 USB 3.0 Host Controller (rev 03)
  0001:00:00.0 PCI bridge: Qualcomm Device 010b
  ```

* 显示设备控制寄存器中的 PCIe 设备和厂商 ID。

  ```shell
  lspci -nvmm
  ```

  示例输出

  ```shell
  Slot:        00:00.0
  Class:        0604
  Vendor:        17cb
  Device:        010b
  IOMMUGroup:        6

  Slot:        01:00.0
  Class:        0c03
  Vendor:        1912
  Device:        0014
  Rev:        03
  ProgIf:        30
  IOMMUGroup:        6

  Slot:        0001:00:00.0
  Class:        0604
  Vendor:        17cb
  Device:        010b
  DTNode:        /sys/firmware/devicetree/base/soc@0/pci@1c08000/pcie@1
  IOMMUGroup:        7

  ```
